# Generated from DParser.g4 by ANTLR 4.9.2
# encoding: utf-8
from antlr4 import *
from io import StringIO
import sys
if sys.version_info[1] > 5:
	from typing import TextIO
else:
	from typing.io import TextIO


def serializedATN():
    with StringIO() as buf:
        buf.write("\3\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964\3J")
        buf.write("\u02d7\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t\7")
        buf.write("\4\b\t\b\4\t\t\t\4\n\t\n\4\13\t\13\4\f\t\f\4\r\t\r\4\16")
        buf.write("\t\16\4\17\t\17\4\20\t\20\4\21\t\21\4\22\t\22\4\23\t\23")
        buf.write("\4\24\t\24\4\25\t\25\4\26\t\26\4\27\t\27\4\30\t\30\4\31")
        buf.write("\t\31\3\2\7\2\64\n\2\f\2\16\2\67\13\2\3\2\3\2\3\3\3\3")
        buf.write("\3\3\5\3>\n\3\3\3\7\3A\n\3\f\3\16\3D\13\3\3\3\3\3\5\3")
        buf.write("H\n\3\3\3\3\3\7\3L\n\3\f\3\16\3O\13\3\3\3\3\3\3\3\3\3")
        buf.write("\5\3U\n\3\3\3\3\3\7\3Y\n\3\f\3\16\3\\\13\3\3\3\3\3\3\3")
        buf.write("\3\3\3\3\3\3\5\3d\n\3\3\3\3\3\3\3\5\3i\n\3\3\3\5\3l\n")
        buf.write("\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\7\3x\n\3\f")
        buf.write("\3\16\3{\13\3\3\3\3\3\3\3\3\3\3\3\3\3\5\3\u0083\n\3\3")
        buf.write("\3\5\3\u0086\n\3\3\3\5\3\u0089\n\3\3\3\3\3\3\3\3\3\7\3")
        buf.write("\u008f\n\3\f\3\16\3\u0092\13\3\3\3\3\3\3\3\3\3\5\3\u0098")
        buf.write("\n\3\3\3\3\3\7\3\u009c\n\3\f\3\16\3\u009f\13\3\3\3\5\3")
        buf.write("\u00a2\n\3\3\3\7\3\u00a5\n\3\f\3\16\3\u00a8\13\3\3\3\3")
        buf.write("\3\3\3\3\3\3\3\3\3\3\3\7\3\u00b1\n\3\f\3\16\3\u00b4\13")
        buf.write("\3\3\3\7\3\u00b7\n\3\f\3\16\3\u00ba\13\3\3\3\3\3\3\3\3")
        buf.write("\3\3\3\7\3\u00c1\n\3\f\3\16\3\u00c4\13\3\3\3\3\3\7\3\u00c8")
        buf.write("\n\3\f\3\16\3\u00cb\13\3\5\3\u00cd\n\3\3\3\7\3\u00d0\n")
        buf.write("\3\f\3\16\3\u00d3\13\3\3\3\3\3\3\3\3\3\7\3\u00d9\n\3\f")
        buf.write("\3\16\3\u00dc\13\3\3\3\3\3\3\3\7\3\u00e1\n\3\f\3\16\3")
        buf.write("\u00e4\13\3\3\3\3\3\3\3\7\3\u00e9\n\3\f\3\16\3\u00ec\13")
        buf.write("\3\3\3\3\3\3\3\3\3\7\3\u00f2\n\3\f\3\16\3\u00f5\13\3\3")
        buf.write("\3\3\3\3\3\7\3\u00fa\n\3\f\3\16\3\u00fd\13\3\3\3\3\3\3")
        buf.write("\3\3\3\7\3\u0103\n\3\f\3\16\3\u0106\13\3\3\3\3\3\3\3\3")
        buf.write("\3\7\3\u010c\n\3\f\3\16\3\u010f\13\3\3\3\3\3\3\3\7\3\u0114")
        buf.write("\n\3\f\3\16\3\u0117\13\3\3\3\3\3\3\3\3\3\7\3\u011d\n\3")
        buf.write("\f\3\16\3\u0120\13\3\3\3\3\3\3\3\3\3\7\3\u0126\n\3\f\3")
        buf.write("\16\3\u0129\13\3\3\3\3\3\3\3\7\3\u012e\n\3\f\3\16\3\u0131")
        buf.write("\13\3\3\3\3\3\3\3\7\3\u0136\n\3\f\3\16\3\u0139\13\3\3")
        buf.write("\3\3\3\3\3\3\3\3\3\7\3\u0140\n\3\f\3\16\3\u0143\13\3\3")
        buf.write("\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3")
        buf.write("\3\3\3\3\3\3\7\3\u0156\n\3\f\3\16\3\u0159\13\3\3\3\7\3")
        buf.write("\u015c\n\3\f\3\16\3\u015f\13\3\3\3\3\3\3\3\3\3\3\3\7\3")
        buf.write("\u0166\n\3\f\3\16\3\u0169\13\3\3\3\3\3\3\3\3\3\3\3\7\3")
        buf.write("\u0170\n\3\f\3\16\3\u0173\13\3\3\3\3\3\3\3\3\3\3\3\7\3")
        buf.write("\u017a\n\3\f\3\16\3\u017d\13\3\3\3\7\3\u0180\n\3\f\3\16")
        buf.write("\3\u0183\13\3\3\3\3\3\3\3\3\3\3\3\7\3\u018a\n\3\f\3\16")
        buf.write("\3\u018d\13\3\3\3\7\3\u0190\n\3\f\3\16\3\u0193\13\3\3")
        buf.write("\3\3\3\3\3\3\3\3\3\7\3\u019a\n\3\f\3\16\3\u019d\13\3\3")
        buf.write("\3\7\3\u01a0\n\3\f\3\16\3\u01a3\13\3\3\3\3\3\3\3\3\3\3")
        buf.write("\3\7\3\u01aa\n\3\f\3\16\3\u01ad\13\3\3\3\7\3\u01b0\n\3")
        buf.write("\f\3\16\3\u01b3\13\3\5\3\u01b5\n\3\3\4\3\4\3\4\3\5\3\5")
        buf.write("\5\5\u01bc\n\5\3\5\3\5\3\6\3\6\3\6\5\6\u01c3\n\6\3\6\3")
        buf.write("\6\5\6\u01c7\n\6\3\6\5\6\u01ca\n\6\3\6\3\6\3\6\3\6\3\6")
        buf.write("\7\6\u01d1\n\6\f\6\16\6\u01d4\13\6\3\6\7\6\u01d7\n\6\f")
        buf.write("\6\16\6\u01da\13\6\3\6\3\6\3\6\3\6\3\6\7\6\u01e1\n\6\f")
        buf.write("\6\16\6\u01e4\13\6\3\6\3\6\3\6\3\6\3\6\3\6\3\6\3\6\3\6")
        buf.write("\3\6\5\6\u01f0\n\6\3\7\3\7\7\7\u01f4\n\7\f\7\16\7\u01f7")
        buf.write("\13\7\3\b\3\b\5\b\u01fb\n\b\3\b\3\b\3\t\3\t\3\t\5\t\u0202")
        buf.write("\n\t\3\t\7\t\u0205\n\t\f\t\16\t\u0208\13\t\3\t\3\t\3\t")
        buf.write("\3\t\5\t\u020e\n\t\3\t\3\t\3\t\7\t\u0213\n\t\f\t\16\t")
        buf.write("\u0216\13\t\3\t\3\t\3\t\3\t\5\t\u021c\n\t\3\t\3\t\3\t")
        buf.write("\3\t\3\t\5\t\u0223\n\t\3\t\3\t\3\t\5\t\u0228\n\t\3\n\3")
        buf.write("\n\3\n\3\n\5\n\u022e\n\n\3\n\3\n\3\n\3\n\5\n\u0234\n\n")
        buf.write("\3\13\3\13\3\13\3\13\3\13\3\13\3\13\3\13\3\13\3\13\5\13")
        buf.write("\u0240\n\13\3\13\3\13\3\13\3\13\3\13\5\13\u0247\n\13\3")
        buf.write("\13\3\13\3\13\3\13\3\13\3\13\7\13\u024f\n\13\f\13\16\13")
        buf.write("\u0252\13\13\5\13\u0254\n\13\3\f\3\f\3\f\3\f\3\f\3\f\3")
        buf.write("\f\3\f\3\f\3\f\3\f\3\f\5\f\u0262\n\f\3\r\3\r\3\r\3\r\5")
        buf.write("\r\u0268\n\r\3\r\3\r\3\r\7\r\u026d\n\r\f\r\16\r\u0270")
        buf.write("\13\r\3\r\7\r\u0273\n\r\f\r\16\r\u0276\13\r\3\16\3\16")
        buf.write("\5\16\u027a\n\16\3\16\3\16\3\16\3\16\7\16\u0280\n\16\f")
        buf.write("\16\16\16\u0283\13\16\3\16\3\16\3\16\3\16\7\16\u0289\n")
        buf.write("\16\f\16\16\16\u028c\13\16\3\16\3\16\5\16\u0290\n\16\3")
        buf.write("\17\3\17\3\17\5\17\u0295\n\17\5\17\u0297\n\17\3\17\3\17")
        buf.write("\3\17\5\17\u029c\n\17\3\20\3\20\3\21\3\21\3\22\3\22\3")
        buf.write("\22\5\22\u02a5\n\22\3\23\3\23\5\23\u02a9\n\23\3\23\3\23")
        buf.write("\5\23\u02ad\n\23\3\23\3\23\5\23\u02b1\n\23\3\23\5\23\u02b4")
        buf.write("\n\23\3\24\3\24\3\24\3\24\6\24\u02ba\n\24\r\24\16\24\u02bb")
        buf.write("\5\24\u02be\n\24\3\25\3\25\3\25\3\25\3\25\5\25\u02c5\n")
        buf.write("\25\3\26\3\26\3\27\3\27\3\27\3\27\3\27\3\27\3\27\3\27")
        buf.write("\5\27\u02d1\n\27\3\30\3\30\3\31\3\31\3\31\2\2\32\2\4\6")
        buf.write("\b\n\f\16\20\22\24\26\30\32\34\36 \"$&(*,.\60\2\3\4\2")
        buf.write("\20\20\30\30\2\u0346\2\65\3\2\2\2\4\u01b4\3\2\2\2\6\u01b6")
        buf.write("\3\2\2\2\b\u01bb\3\2\2\2\n\u01ef\3\2\2\2\f\u01f1\3\2\2")
        buf.write("\2\16\u01fa\3\2\2\2\20\u0227\3\2\2\2\22\u0233\3\2\2\2")
        buf.write("\24\u0253\3\2\2\2\26\u0261\3\2\2\2\30\u0267\3\2\2\2\32")
        buf.write("\u028f\3\2\2\2\34\u0296\3\2\2\2\36\u029d\3\2\2\2 \u029f")
        buf.write("\3\2\2\2\"\u02a4\3\2\2\2$\u02b3\3\2\2\2&\u02bd\3\2\2\2")
        buf.write("(\u02c4\3\2\2\2*\u02c6\3\2\2\2,\u02d0\3\2\2\2.\u02d2\3")
        buf.write("\2\2\2\60\u02d4\3\2\2\2\62\64\5\4\3\2\63\62\3\2\2\2\64")
        buf.write("\67\3\2\2\2\65\63\3\2\2\2\65\66\3\2\2\2\668\3\2\2\2\67")
        buf.write("\65\3\2\2\289\7\2\2\39\3\3\2\2\2:;\7\7\2\2;=\5\36\20\2")
        buf.write("<>\5&\24\2=<\3\2\2\2=>\3\2\2\2>B\3\2\2\2?A\5\n\6\2@?\3")
        buf.write("\2\2\2AD\3\2\2\2B@\3\2\2\2BC\3\2\2\2C\u01b5\3\2\2\2DB")
        buf.write("\3\2\2\2EG\7$\2\2FH\7 \2\2GF\3\2\2\2GH\3\2\2\2HI\3\2\2")
        buf.write("\2IM\5\36\20\2JL\5\n\6\2KJ\3\2\2\2LO\3\2\2\2MK\3\2\2\2")
        buf.write("MN\3\2\2\2NP\3\2\2\2OM\3\2\2\2PQ\7\b\2\2Q\u01b5\3\2\2")
        buf.write("\2RT\7%\2\2SU\7 \2\2TS\3\2\2\2TU\3\2\2\2UV\3\2\2\2VZ\5")
        buf.write("\36\20\2WY\5\n\6\2XW\3\2\2\2Y\\\3\2\2\2ZX\3\2\2\2Z[\3")
        buf.write("\2\2\2[]\3\2\2\2\\Z\3\2\2\2]^\7\b\2\2^\u01b5\3\2\2\2_")
        buf.write("h\7&\2\2`c\7\t\2\2ab\7\13\2\2bd\5.\30\2ca\3\2\2\2cd\3")
        buf.write("\2\2\2de\3\2\2\2ef\5&\24\2fg\7\f\2\2gi\3\2\2\2h`\3\2\2")
        buf.write("\2hi\3\2\2\2ik\3\2\2\2jl\7 \2\2kj\3\2\2\2kl\3\2\2\2lm")
        buf.write("\3\2\2\2mn\5\36\20\2no\5&\24\2op\5\30\r\2pq\5\24\13\2")
        buf.write("q\u01b5\3\2\2\2rs\7\'\2\2st\5\36\20\2tu\5&\24\2uy\5&\24")
        buf.write("\2vx\5\32\16\2wv\3\2\2\2x{\3\2\2\2yw\3\2\2\2yz\3\2\2\2")
        buf.write("z|\3\2\2\2{y\3\2\2\2|}\5\24\13\2}\u01b5\3\2\2\2~\u0083")
        buf.write("\7:\2\2\177\u0083\7;\2\2\u0080\u0083\7<\2\2\u0081\u0083")
        buf.write("\7=\2\2\u0082~\3\2\2\2\u0082\177\3\2\2\2\u0082\u0080\3")
        buf.write("\2\2\2\u0082\u0081\3\2\2\2\u0083\u0085\3\2\2\2\u0084\u0086")
        buf.write("\7\33\2\2\u0085\u0084\3\2\2\2\u0085\u0086\3\2\2\2\u0086")
        buf.write("\u0088\3\2\2\2\u0087\u0089\7 \2\2\u0088\u0087\3\2\2\2")
        buf.write("\u0088\u0089\3\2\2\2\u0089\u008a\3\2\2\2\u008a\u008b\5")
        buf.write("\36\20\2\u008b\u008c\5&\24\2\u008c\u0090\5&\24\2\u008d")
        buf.write("\u008f\5\32\16\2\u008e\u008d\3\2\2\2\u008f\u0092\3\2\2")
        buf.write("\2\u0090\u008e\3\2\2\2\u0090\u0091\3\2\2\2\u0091\u0093")
        buf.write("\3\2\2\2\u0092\u0090\3\2\2\2\u0093\u0094\7\b\2\2\u0094")
        buf.write("\u01b5\3\2\2\2\u0095\u0098\7(\2\2\u0096\u0098\79\2\2\u0097")
        buf.write("\u0095\3\2\2\2\u0097\u0096\3\2\2\2\u0098\u0099\3\2\2\2")
        buf.write("\u0099\u009d\5\36\20\2\u009a\u009c\5&\24\2\u009b\u009a")
        buf.write("\3\2\2\2\u009c\u009f\3\2\2\2\u009d\u009b\3\2\2\2\u009d")
        buf.write("\u009e\3\2\2\2\u009e\u00a1\3\2\2\2\u009f\u009d\3\2\2\2")
        buf.write("\u00a0\u00a2\5.\30\2\u00a1\u00a0\3\2\2\2\u00a1\u00a2\3")
        buf.write("\2\2\2\u00a2\u00a6\3\2\2\2\u00a3\u00a5\5\20\t\2\u00a4")
        buf.write("\u00a3\3\2\2\2\u00a5\u00a8\3\2\2\2\u00a6\u00a4\3\2\2\2")
        buf.write("\u00a6\u00a7\3\2\2\2\u00a7\u00a9\3\2\2\2\u00a8\u00a6\3")
        buf.write("\2\2\2\u00a9\u00aa\7\b\2\2\u00aa\u01b5\3\2\2\2\u00ab\u00ac")
        buf.write("\7)\2\2\u00ac\u00ad\5\36\20\2\u00ad\u00ae\5&\24\2\u00ae")
        buf.write("\u00b2\5&\24\2\u00af\u00b1\5&\24\2\u00b0\u00af\3\2\2\2")
        buf.write("\u00b1\u00b4\3\2\2\2\u00b2\u00b0\3\2\2\2\u00b2\u00b3\3")
        buf.write("\2\2\2\u00b3\u00b8\3\2\2\2\u00b4\u00b2\3\2\2\2\u00b5\u00b7")
        buf.write("\5\b\5\2\u00b6\u00b5\3\2\2\2\u00b7\u00ba\3\2\2\2\u00b8")
        buf.write("\u00b6\3\2\2\2\u00b8\u00b9\3\2\2\2\u00b9\u01b5\3\2\2\2")
        buf.write("\u00ba\u00b8\3\2\2\2\u00bb\u00bc\7*\2\2\u00bc\u00bd\5")
        buf.write("\36\20\2\u00bd\u00be\5&\24\2\u00be\u00c2\5&\24\2\u00bf")
        buf.write("\u00c1\5&\24\2\u00c0\u00bf\3\2\2\2\u00c1\u00c4\3\2\2\2")
        buf.write("\u00c2\u00c0\3\2\2\2\u00c2\u00c3\3\2\2\2\u00c3\u00cc\3")
        buf.write("\2\2\2\u00c4\u00c2\3\2\2\2\u00c5\u00c9\7\23\2\2\u00c6")
        buf.write("\u00c8\5&\24\2\u00c7\u00c6\3\2\2\2\u00c8\u00cb\3\2\2\2")
        buf.write("\u00c9\u00c7\3\2\2\2\u00c9\u00ca\3\2\2\2\u00ca\u00cd\3")
        buf.write("\2\2\2\u00cb\u00c9\3\2\2\2\u00cc\u00c5\3\2\2\2\u00cc\u00cd")
        buf.write("\3\2\2\2\u00cd\u00d1\3\2\2\2\u00ce\u00d0\5\b\5\2\u00cf")
        buf.write("\u00ce\3\2\2\2\u00d0\u00d3\3\2\2\2\u00d1\u00cf\3\2\2\2")
        buf.write("\u00d1\u00d2\3\2\2\2\u00d2\u01b5\3\2\2\2\u00d3\u00d1\3")
        buf.write("\2\2\2\u00d4\u00d5\7+\2\2\u00d5\u00d6\5\36\20\2\u00d6")
        buf.write("\u00da\7\7\2\2\u00d7\u00d9\5&\24\2\u00d8\u00d7\3\2\2\2")
        buf.write("\u00d9\u00dc\3\2\2\2\u00da\u00d8\3\2\2\2\u00da\u00db\3")
        buf.write("\2\2\2\u00db\u00dd\3\2\2\2\u00dc\u00da\3\2\2\2\u00dd\u00de")
        buf.write("\7\b\2\2\u00de\u00e2\7\7\2\2\u00df\u00e1\5&\24\2\u00e0")
        buf.write("\u00df\3\2\2\2\u00e1\u00e4\3\2\2\2\u00e2\u00e0\3\2\2\2")
        buf.write("\u00e2\u00e3\3\2\2\2\u00e3\u00e5\3\2\2\2\u00e4\u00e2\3")
        buf.write("\2\2\2\u00e5\u00e6\7\b\2\2\u00e6\u00ea\5&\24\2\u00e7\u00e9")
        buf.write("\5\b\5\2\u00e8\u00e7\3\2\2\2\u00e9\u00ec\3\2\2\2\u00ea")
        buf.write("\u00e8\3\2\2\2\u00ea\u00eb\3\2\2\2\u00eb\u01b5\3\2\2\2")
        buf.write("\u00ec\u00ea\3\2\2\2\u00ed\u00ee\7,\2\2\u00ee\u00ef\5")
        buf.write("\36\20\2\u00ef\u00f3\7\7\2\2\u00f0\u00f2\5&\24\2\u00f1")
        buf.write("\u00f0\3\2\2\2\u00f2\u00f5\3\2\2\2\u00f3\u00f1\3\2\2\2")
        buf.write("\u00f3\u00f4\3\2\2\2\u00f4\u00f6\3\2\2\2\u00f5\u00f3\3")
        buf.write("\2\2\2\u00f6\u00f7\7\b\2\2\u00f7\u00fb\7\7\2\2\u00f8\u00fa")
        buf.write("\5&\24\2\u00f9\u00f8\3\2\2\2\u00fa\u00fd\3\2\2\2\u00fb")
        buf.write("\u00f9\3\2\2\2\u00fb\u00fc\3\2\2\2\u00fc\u00fe\3\2\2\2")
        buf.write("\u00fd\u00fb\3\2\2\2\u00fe\u00ff\7\b\2\2\u00ff\u0100\5")
        buf.write("&\24\2\u0100\u0104\5&\24\2\u0101\u0103\5\b\5\2\u0102\u0101")
        buf.write("\3\2\2\2\u0103\u0106\3\2\2\2\u0104\u0102\3\2\2\2\u0104")
        buf.write("\u0105\3\2\2\2\u0105\u01b5\3\2\2\2\u0106\u0104\3\2\2\2")
        buf.write("\u0107\u0108\7-\2\2\u0108\u0109\5\36\20\2\u0109\u010d")
        buf.write("\7\7\2\2\u010a\u010c\5&\24\2\u010b\u010a\3\2\2\2\u010c")
        buf.write("\u010f\3\2\2\2\u010d\u010b\3\2\2\2\u010d\u010e\3\2\2\2")
        buf.write("\u010e\u0110\3\2\2\2\u010f\u010d\3\2\2\2\u0110\u0111\7")
        buf.write("\b\2\2\u0111\u0115\7\7\2\2\u0112\u0114\5&\24\2\u0113\u0112")
        buf.write("\3\2\2\2\u0114\u0117\3\2\2\2\u0115\u0113\3\2\2\2\u0115")
        buf.write("\u0116\3\2\2\2\u0116\u0118\3\2\2\2\u0117\u0115\3\2\2\2")
        buf.write("\u0118\u0119\7\b\2\2\u0119\u011a\5&\24\2\u011a\u011e\5")
        buf.write("&\24\2\u011b\u011d\5\b\5\2\u011c\u011b\3\2\2\2\u011d\u0120")
        buf.write("\3\2\2\2\u011e\u011c\3\2\2\2\u011e\u011f\3\2\2\2\u011f")
        buf.write("\u01b5\3\2\2\2\u0120\u011e\3\2\2\2\u0121\u0122\7.\2\2")
        buf.write("\u0122\u0123\5\36\20\2\u0123\u0127\7\7\2\2\u0124\u0126")
        buf.write("\5&\24\2\u0125\u0124\3\2\2\2\u0126\u0129\3\2\2\2\u0127")
        buf.write("\u0125\3\2\2\2\u0127\u0128\3\2\2\2\u0128\u012a\3\2\2\2")
        buf.write("\u0129\u0127\3\2\2\2\u012a\u012b\7\b\2\2\u012b\u012f\7")
        buf.write("\7\2\2\u012c\u012e\5&\24\2\u012d\u012c\3\2\2\2\u012e\u0131")
        buf.write("\3\2\2\2\u012f\u012d\3\2\2\2\u012f\u0130\3\2\2\2\u0130")
        buf.write("\u0132\3\2\2\2\u0131\u012f\3\2\2\2\u0132\u0133\7\b\2\2")
        buf.write("\u0133\u0137\7\7\2\2\u0134\u0136\5\6\4\2\u0135\u0134\3")
        buf.write("\2\2\2\u0136\u0139\3\2\2\2\u0137\u0135\3\2\2\2\u0137\u0138")
        buf.write("\3\2\2\2\u0138\u013a\3\2\2\2\u0139\u0137\3\2\2\2\u013a")
        buf.write("\u013b\7\b\2\2\u013b\u01b5\3\2\2\2\u013c\u013d\7/\2\2")
        buf.write("\u013d\u0141\5\36\20\2\u013e\u0140\5\n\6\2\u013f\u013e")
        buf.write("\3\2\2\2\u0140\u0143\3\2\2\2\u0141\u013f\3\2\2\2\u0141")
        buf.write("\u0142\3\2\2\2\u0142\u0144\3\2\2\2\u0143\u0141\3\2\2\2")
        buf.write("\u0144\u0145\7\b\2\2\u0145\u01b5\3\2\2\2\u0146\u0147\7")
        buf.write("\60\2\2\u0147\u0148\5\36\20\2\u0148\u0149\5&\24\2\u0149")
        buf.write("\u014a\5.\30\2\u014a\u01b5\3\2\2\2\u014b\u014c\78\2\2")
        buf.write("\u014c\u014d\5\36\20\2\u014d\u014e\5&\24\2\u014e\u014f")
        buf.write("\5 \21\2\u014f\u01b5\3\2\2\2\u0150\u0151\7\61\2\2\u0151")
        buf.write("\u0152\5\36\20\2\u0152\u0153\5&\24\2\u0153\u0157\5&\24")
        buf.write("\2\u0154\u0156\5&\24\2\u0155\u0154\3\2\2\2\u0156\u0159")
        buf.write("\3\2\2\2\u0157\u0155\3\2\2\2\u0157\u0158\3\2\2\2\u0158")
        buf.write("\u015d\3\2\2\2\u0159\u0157\3\2\2\2\u015a\u015c\5\b\5\2")
        buf.write("\u015b\u015a\3\2\2\2\u015c\u015f\3\2\2\2\u015d\u015b\3")
        buf.write("\2\2\2\u015d\u015e\3\2\2\2\u015e\u01b5\3\2\2\2\u015f\u015d")
        buf.write("\3\2\2\2\u0160\u0161\7\62\2\2\u0161\u0162\5\36\20\2\u0162")
        buf.write("\u0163\5&\24\2\u0163\u0167\5&\24\2\u0164\u0166\5\b\5\2")
        buf.write("\u0165\u0164\3\2\2\2\u0166\u0169\3\2\2\2\u0167\u0165\3")
        buf.write("\2\2\2\u0167\u0168\3\2\2\2\u0168\u01b5\3\2\2\2\u0169\u0167")
        buf.write("\3\2\2\2\u016a\u016b\7\63\2\2\u016b\u016c\5&\24\2\u016c")
        buf.write("\u016d\5&\24\2\u016d\u0171\5&\24\2\u016e\u0170\5\b\5\2")
        buf.write("\u016f\u016e\3\2\2\2\u0170\u0173\3\2\2\2\u0171\u016f\3")
        buf.write("\2\2\2\u0171\u0172\3\2\2\2\u0172\u01b5\3\2\2\2\u0173\u0171")
        buf.write("\3\2\2\2\u0174\u0175\7\64\2\2\u0175\u0176\5\36\20\2\u0176")
        buf.write("\u0177\5&\24\2\u0177\u017b\5&\24\2\u0178\u017a\5\36\20")
        buf.write("\2\u0179\u0178\3\2\2\2\u017a\u017d\3\2\2\2\u017b\u0179")
        buf.write("\3\2\2\2\u017b\u017c\3\2\2\2\u017c\u0181\3\2\2\2\u017d")
        buf.write("\u017b\3\2\2\2\u017e\u0180\5\b\5\2\u017f\u017e\3\2\2\2")
        buf.write("\u0180\u0183\3\2\2\2\u0181\u017f\3\2\2\2\u0181\u0182\3")
        buf.write("\2\2\2\u0182\u01b5\3\2\2\2\u0183\u0181\3\2\2\2\u0184\u0185")
        buf.write("\7\65\2\2\u0185\u0186\5&\24\2\u0186\u0187\5&\24\2\u0187")
        buf.write("\u018b\5&\24\2\u0188\u018a\5&\24\2\u0189\u0188\3\2\2\2")
        buf.write("\u018a\u018d\3\2\2\2\u018b\u0189\3\2\2\2\u018b\u018c\3")
        buf.write("\2\2\2\u018c\u0191\3\2\2\2\u018d\u018b\3\2\2\2\u018e\u0190")
        buf.write("\5\b\5\2\u018f\u018e\3\2\2\2\u0190\u0193\3\2\2\2\u0191")
        buf.write("\u018f\3\2\2\2\u0191\u0192\3\2\2\2\u0192\u01b5\3\2\2\2")
        buf.write("\u0193\u0191\3\2\2\2\u0194\u0195\7\66\2\2\u0195\u0196")
        buf.write("\5\36\20\2\u0196\u0197\5&\24\2\u0197\u019b\5&\24\2\u0198")
        buf.write("\u019a\5\36\20\2\u0199\u0198\3\2\2\2\u019a\u019d\3\2\2")
        buf.write("\2\u019b\u0199\3\2\2\2\u019b\u019c\3\2\2\2\u019c\u01a1")
        buf.write("\3\2\2\2\u019d\u019b\3\2\2\2\u019e\u01a0\5\b\5\2\u019f")
        buf.write("\u019e\3\2\2\2\u01a0\u01a3\3\2\2\2\u01a1\u019f\3\2\2\2")
        buf.write("\u01a1\u01a2\3\2\2\2\u01a2\u01b5\3\2\2\2\u01a3\u01a1\3")
        buf.write("\2\2\2\u01a4\u01a5\7\67\2\2\u01a5\u01a6\5&\24\2\u01a6")
        buf.write("\u01a7\5&\24\2\u01a7\u01ab\5&\24\2\u01a8\u01aa\5&\24\2")
        buf.write("\u01a9\u01a8\3\2\2\2\u01aa\u01ad\3\2\2\2\u01ab\u01a9\3")
        buf.write("\2\2\2\u01ab\u01ac\3\2\2\2\u01ac\u01b1\3\2\2\2\u01ad\u01ab")
        buf.write("\3\2\2\2\u01ae\u01b0\5\b\5\2\u01af\u01ae\3\2\2\2\u01b0")
        buf.write("\u01b3\3\2\2\2\u01b1\u01af\3\2\2\2\u01b1\u01b2\3\2\2\2")
        buf.write("\u01b2\u01b5\3\2\2\2\u01b3\u01b1\3\2\2\2\u01b4:\3\2\2")
        buf.write("\2\u01b4E\3\2\2\2\u01b4R\3\2\2\2\u01b4_\3\2\2\2\u01b4")
        buf.write("r\3\2\2\2\u01b4\u0082\3\2\2\2\u01b4\u0097\3\2\2\2\u01b4")
        buf.write("\u00ab\3\2\2\2\u01b4\u00bb\3\2\2\2\u01b4\u00d4\3\2\2\2")
        buf.write("\u01b4\u00ed\3\2\2\2\u01b4\u0107\3\2\2\2\u01b4\u0121\3")
        buf.write("\2\2\2\u01b4\u013c\3\2\2\2\u01b4\u0146\3\2\2\2\u01b4\u014b")
        buf.write("\3\2\2\2\u01b4\u0150\3\2\2\2\u01b4\u0160\3\2\2\2\u01b4")
        buf.write("\u016a\3\2\2\2\u01b4\u0174\3\2\2\2\u01b4\u0184\3\2\2\2")
        buf.write("\u01b4\u0194\3\2\2\2\u01b4\u01a4\3\2\2\2\u01b5\5\3\2\2")
        buf.write("\2\u01b6\u01b7\5&\24\2\u01b7\u01b8\5&\24\2\u01b8\7\3\2")
        buf.write("\2\2\u01b9\u01bc\7\t\2\2\u01ba\u01bc\7\n\2\2\u01bb\u01b9")
        buf.write("\3\2\2\2\u01bb\u01ba\3\2\2\2\u01bc\u01bd\3\2\2\2\u01bd")
        buf.write("\u01be\5&\24\2\u01be\t\3\2\2\2\u01bf\u01c2\7\t\2\2\u01c0")
        buf.write("\u01c1\7\13\2\2\u01c1\u01c3\5.\30\2\u01c2\u01c0\3\2\2")
        buf.write("\2\u01c2\u01c3\3\2\2\2\u01c3\u01c4\3\2\2\2\u01c4\u01c6")
        buf.write("\5&\24\2\u01c5\u01c7\7\f\2\2\u01c6\u01c5\3\2\2\2\u01c6")
        buf.write("\u01c7\3\2\2\2\u01c7\u01c9\3\2\2\2\u01c8\u01ca\7\7\2\2")
        buf.write("\u01c9\u01c8\3\2\2\2\u01c9\u01ca\3\2\2\2\u01ca\u01cb\3")
        buf.write("\2\2\2\u01cb\u01cc\5&\24\2\u01cc\u01cd\7\37\2\2\u01cd")
        buf.write("\u01d2\5 \21\2\u01ce\u01cf\7\r\2\2\u01cf\u01d1\5 \21\2")
        buf.write("\u01d0\u01ce\3\2\2\2\u01d1\u01d4\3\2\2\2\u01d2\u01d0\3")
        buf.write("\2\2\2\u01d2\u01d3\3\2\2\2\u01d3\u01d8\3\2\2\2\u01d4\u01d2")
        buf.write("\3\2\2\2\u01d5\u01d7\5\20\t\2\u01d6\u01d5\3\2\2\2\u01d7")
        buf.write("\u01da\3\2\2\2\u01d8\u01d6\3\2\2\2\u01d8\u01d9\3\2\2\2")
        buf.write("\u01d9\u01db\3\2\2\2\u01da\u01d8\3\2\2\2\u01db\u01dc\7")
        buf.write("\b\2\2\u01dc\u01f0\3\2\2\2\u01dd\u01de\7\31\2\2\u01de")
        buf.write("\u01e2\5\36\20\2\u01df\u01e1\5\n\6\2\u01e0\u01df\3\2\2")
        buf.write("\2\u01e1\u01e4\3\2\2\2\u01e2\u01e0\3\2\2\2\u01e2\u01e3")
        buf.write("\3\2\2\2\u01e3\u01e5\3\2\2\2\u01e4\u01e2\3\2\2\2\u01e5")
        buf.write("\u01e6\7\b\2\2\u01e6\u01f0\3\2\2\2\u01e7\u01e8\7\32\2")
        buf.write("\2\u01e8\u01e9\5\36\20\2\u01e9\u01ea\5&\24\2\u01ea\u01eb")
        buf.write("\5\f\7\2\u01eb\u01ec\7\b\2\2\u01ec\u01ed\5\36\20\2\u01ed")
        buf.write("\u01ee\5&\24\2\u01ee\u01f0\3\2\2\2\u01ef\u01bf\3\2\2\2")
        buf.write("\u01ef\u01dd\3\2\2\2\u01ef\u01e7\3\2\2\2\u01f0\13\3\2")
        buf.write("\2\2\u01f1\u01f5\5\34\17\2\u01f2\u01f4\5\16\b\2\u01f3")
        buf.write("\u01f2\3\2\2\2\u01f4\u01f7\3\2\2\2\u01f5\u01f3\3\2\2\2")
        buf.write("\u01f5\u01f6\3\2\2\2\u01f6\r\3\2\2\2\u01f7\u01f5\3\2\2")
        buf.write("\2\u01f8\u01fb\7\16\2\2\u01f9\u01fb\7\r\2\2\u01fa\u01f8")
        buf.write("\3\2\2\2\u01fa\u01f9\3\2\2\2\u01fb\u01fc\3\2\2\2\u01fc")
        buf.write("\u01fd\5\34\17\2\u01fd\17\3\2\2\2\u01fe\u01ff\7\t\2\2")
        buf.write("\u01ff\u0201\5&\24\2\u0200\u0202\7\f\2\2\u0201\u0200\3")
        buf.write("\2\2\2\u0201\u0202\3\2\2\2\u0202\u0206\3\2\2\2\u0203\u0205")
        buf.write("\5\26\f\2\u0204\u0203\3\2\2\2\u0205\u0208\3\2\2\2\u0206")
        buf.write("\u0204\3\2\2\2\u0206\u0207\3\2\2\2\u0207\u0209\3\2\2\2")
        buf.write("\u0208\u0206\3\2\2\2\u0209\u020a\5\22\n\2\u020a\u0228")
        buf.write("\3\2\2\2\u020b\u020d\7\20\2\2\u020c\u020e\5&\24\2\u020d")
        buf.write("\u020c\3\2\2\2\u020d\u020e\3\2\2\2\u020e\u020f\3\2\2\2")
        buf.write("\u020f\u0210\7\20\2\2\u0210\u0214\5 \21\2\u0211\u0213")
        buf.write("\5\26\f\2\u0212\u0211\3\2\2\2\u0213\u0216\3\2\2\2\u0214")
        buf.write("\u0212\3\2\2\2\u0214\u0215\3\2\2\2\u0215\u0217\3\2\2\2")
        buf.write("\u0216\u0214\3\2\2\2\u0217\u0218\5\22\n\2\u0218\u0228")
        buf.write("\3\2\2\2\u0219\u021b\7\21\2\2\u021a\u021c\7\33\2\2\u021b")
        buf.write("\u021a\3\2\2\2\u021b\u021c\3\2\2\2\u021c\u021d\3\2\2\2")
        buf.write("\u021d\u021e\5\36\20\2\u021e\u021f\5&\24\2\u021f\u0228")
        buf.write("\3\2\2\2\u0220\u0222\7\22\2\2\u0221\u0223\7\33\2\2\u0222")
        buf.write("\u0221\3\2\2\2\u0222\u0223\3\2\2\2\u0223\u0224\3\2\2\2")
        buf.write("\u0224\u0225\5\36\20\2\u0225\u0226\5&\24\2\u0226\u0228")
        buf.write("\3\2\2\2\u0227\u01fe\3\2\2\2\u0227\u020b\3\2\2\2\u0227")
        buf.write("\u0219\3\2\2\2\u0227\u0220\3\2\2\2\u0228\21\3\2\2\2\u0229")
        buf.write("\u022a\t\2\2\2\u022a\u0234\5&\24\2\u022b\u022d\7\34\2")
        buf.write("\2\u022c\u022e\7 \2\2\u022d\u022c\3\2\2\2\u022d\u022e")
        buf.write("\3\2\2\2\u022e\u022f\3\2\2\2\u022f\u0230\5\36\20\2\u0230")
        buf.write("\u0231\5&\24\2\u0231\u0234\3\2\2\2\u0232\u0234\7\36\2")
        buf.write("\2\u0233\u0229\3\2\2\2\u0233\u022b\3\2\2\2\u0233\u0232")
        buf.write("\3\2\2\2\u0234\23\3\2\2\2\u0235\u0236\7\b\2\2\u0236\u0237")
        buf.write("\5\36\20\2\u0237\u0238\5&\24\2\u0238\u0254\3\2\2\2\u0239")
        buf.write("\u023a\7\34\2\2\u023a\u023b\5\36\20\2\u023b\u023c\5&\24")
        buf.write("\2\u023c\u0254\3\2\2\2\u023d\u023f\7\21\2\2\u023e\u0240")
        buf.write("\7\33\2\2\u023f\u023e\3\2\2\2\u023f\u0240\3\2\2\2\u0240")
        buf.write("\u0241\3\2\2\2\u0241\u0242\5\36\20\2\u0242\u0243\5&\24")
        buf.write("\2\u0243\u0254\3\2\2\2\u0244\u0246\7\22\2\2\u0245\u0247")
        buf.write("\7\33\2\2\u0246\u0245\3\2\2\2\u0246\u0247\3\2\2\2\u0247")
        buf.write("\u0248\3\2\2\2\u0248\u0249\5\36\20\2\u0249\u024a\5&\24")
        buf.write("\2\u024a\u0254\3\2\2\2\u024b\u0254\7\36\2\2\u024c\u0250")
        buf.write("\7\b\2\2\u024d\u024f\5\20\t\2\u024e\u024d\3\2\2\2\u024f")
        buf.write("\u0252\3\2\2\2\u0250\u024e\3\2\2\2\u0250\u0251\3\2\2\2")
        buf.write("\u0251\u0254\3\2\2\2\u0252\u0250\3\2\2\2\u0253\u0235\3")
        buf.write("\2\2\2\u0253\u0239\3\2\2\2\u0253\u023d\3\2\2\2\u0253\u0244")
        buf.write("\3\2\2\2\u0253\u024b\3\2\2\2\u0253\u024c\3\2\2\2\u0254")
        buf.write("\25\3\2\2\2\u0255\u0256\7\35\2\2\u0256\u0262\5$\23\2\u0257")
        buf.write("\u0258\7\23\2\2\u0258\u0262\5&\24\2\u0259\u025a\7\24\2")
        buf.write("\2\u025a\u0262\5$\23\2\u025b\u025c\7\25\2\2\u025c\u0262")
        buf.write("\5$\23\2\u025d\u025e\7\26\2\2\u025e\u0262\5$\23\2\u025f")
        buf.write("\u0260\7\27\2\2\u0260\u0262\5&\24\2\u0261\u0255\3\2\2")
        buf.write("\2\u0261\u0257\3\2\2\2\u0261\u0259\3\2\2\2\u0261\u025b")
        buf.write("\3\2\2\2\u0261\u025d\3\2\2\2\u0261\u025f\3\2\2\2\u0262")
        buf.write("\27\3\2\2\2\u0263\u0264\7\t\2\2\u0264\u0265\5&\24\2\u0265")
        buf.write("\u0266\7\f\2\2\u0266\u0268\3\2\2\2\u0267\u0263\3\2\2\2")
        buf.write("\u0267\u0268\3\2\2\2\u0268\u0269\3\2\2\2\u0269\u026e\5")
        buf.write("\34\17\2\u026a\u026b\7\r\2\2\u026b\u026d\5\34\17\2\u026c")
        buf.write("\u026a\3\2\2\2\u026d\u0270\3\2\2\2\u026e\u026c\3\2\2\2")
        buf.write("\u026e\u026f\3\2\2\2\u026f\u0274\3\2\2\2\u0270\u026e\3")
        buf.write("\2\2\2\u0271\u0273\5\32\16\2\u0272\u0271\3\2\2\2\u0273")
        buf.write("\u0276\3\2\2\2\u0274\u0272\3\2\2\2\u0274\u0275\3\2\2\2")
        buf.write("\u0275\31\3\2\2\2\u0276\u0274\3\2\2\2\u0277\u0279\7\16")
        buf.write("\2\2\u0278\u027a\7 \2\2\u0279\u0278\3\2\2\2\u0279\u027a")
        buf.write("\3\2\2\2\u027a\u027b\3\2\2\2\u027b\u027c\5\36\20\2\u027c")
        buf.write("\u0281\5\34\17\2\u027d\u027e\7\r\2\2\u027e\u0280\5\34")
        buf.write("\17\2\u027f\u027d\3\2\2\2\u0280\u0283\3\2\2\2\u0281\u027f")
        buf.write("\3\2\2\2\u0281\u0282\3\2\2\2\u0282\u0290\3\2\2\2\u0283")
        buf.write("\u0281\3\2\2\2\u0284\u0285\7\17\2\2\u0285\u0286\5&\24")
        buf.write("\2\u0286\u028a\7\7\2\2\u0287\u0289\5\32\16\2\u0288\u0287")
        buf.write("\3\2\2\2\u0289\u028c\3\2\2\2\u028a\u0288\3\2\2\2\u028a")
        buf.write("\u028b\3\2\2\2\u028b\u028d\3\2\2\2\u028c\u028a\3\2\2\2")
        buf.write("\u028d\u028e\7\b\2\2\u028e\u0290\3\2\2\2\u028f\u0277\3")
        buf.write("\2\2\2\u028f\u0284\3\2\2\2\u0290\33\3\2\2\2\u0291\u0292")
        buf.write("\7\t\2\2\u0292\u0294\5&\24\2\u0293\u0295\7\f\2\2\u0294")
        buf.write("\u0293\3\2\2\2\u0294\u0295\3\2\2\2\u0295\u0297\3\2\2\2")
        buf.write("\u0296\u0291\3\2\2\2\u0296\u0297\3\2\2\2\u0297\u0298\3")
        buf.write("\2\2\2\u0298\u029b\5 \21\2\u0299\u029a\7\23\2\2\u029a")
        buf.write("\u029c\5&\24\2\u029b\u0299\3\2\2\2\u029b\u029c\3\2\2\2")
        buf.write("\u029c\35\3\2\2\2\u029d\u029e\5&\24\2\u029e\37\3\2\2\2")
        buf.write("\u029f\u02a0\5$\23\2\u02a0!\3\2\2\2\u02a1\u02a5\5&\24")
        buf.write("\2\u02a2\u02a5\5,\27\2\u02a3\u02a5\5$\23\2\u02a4\u02a1")
        buf.write("\3\2\2\2\u02a4\u02a2\3\2\2\2\u02a4\u02a3\3\2\2\2\u02a5")
        buf.write("#\3\2\2\2\u02a6\u02a8\5&\24\2\u02a7\u02a9\5\60\31\2\u02a8")
        buf.write("\u02a7\3\2\2\2\u02a8\u02a9\3\2\2\2\u02a9\u02aa\3\2\2\2")
        buf.write("\u02aa\u02ac\5&\24\2\u02ab\u02ad\5\60\31\2\u02ac\u02ab")
        buf.write("\3\2\2\2\u02ac\u02ad\3\2\2\2\u02ad\u02b4\3\2\2\2\u02ae")
        buf.write("\u02b0\5&\24\2\u02af\u02b1\5\60\31\2\u02b0\u02af\3\2\2")
        buf.write("\2\u02b0\u02b1\3\2\2\2\u02b1\u02b4\3\2\2\2\u02b2\u02b4")
        buf.write("\5,\27\2\u02b3\u02a6\3\2\2\2\u02b3\u02ae\3\2\2\2\u02b3")
        buf.write("\u02b2\3\2\2\2\u02b4%\3\2\2\2\u02b5\u02be\5(\25\2\u02b6")
        buf.write("\u02b9\5(\25\2\u02b7\u02b8\7F\2\2\u02b8\u02ba\5(\25\2")
        buf.write("\u02b9\u02b7\3\2\2\2\u02ba\u02bb\3\2\2\2\u02bb\u02b9\3")
        buf.write("\2\2\2\u02bb\u02bc\3\2\2\2\u02bc\u02be\3\2\2\2\u02bd\u02b5")
        buf.write("\3\2\2\2\u02bd\u02b6\3\2\2\2\u02be\'\3\2\2\2\u02bf\u02c5")
        buf.write("\5*\26\2\u02c0\u02c5\7C\2\2\u02c1\u02c5\7A\2\2\u02c2\u02c5")
        buf.write("\7G\2\2\u02c3\u02c5\7B\2\2\u02c4\u02bf\3\2\2\2\u02c4\u02c0")
        buf.write("\3\2\2\2\u02c4\u02c1\3\2\2\2\u02c4\u02c2\3\2\2\2\u02c4")
        buf.write("\u02c3\3\2\2\2\u02c5)\3\2\2\2\u02c6\u02c7\7>\2\2\u02c7")
        buf.write("+\3\2\2\2\u02c8\u02d1\7?\2\2\u02c9\u02d1\7D\2\2\u02ca")
        buf.write("\u02d1\7E\2\2\u02cb\u02cc\7!\2\2\u02cc\u02cd\7#\2\2\u02cd")
        buf.write("\u02ce\5&\24\2\u02ce\u02cf\7\"\2\2\u02cf\u02d1\3\2\2\2")
        buf.write("\u02d0\u02c8\3\2\2\2\u02d0\u02c9\3\2\2\2\u02d0\u02ca\3")
        buf.write("\2\2\2\u02d0\u02cb\3\2\2\2\u02d1-\3\2\2\2\u02d2\u02d3")
        buf.write("\7?\2\2\u02d3/\3\2\2\2\u02d4\u02d5\7@\2\2\u02d5\61\3\2")
        buf.write("\2\2`\65=BGMTZchky\u0082\u0085\u0088\u0090\u0097\u009d")
        buf.write("\u00a1\u00a6\u00b2\u00b8\u00c2\u00c9\u00cc\u00d1\u00da")
        buf.write("\u00e2\u00ea\u00f3\u00fb\u0104\u010d\u0115\u011e\u0127")
        buf.write("\u012f\u0137\u0141\u0157\u015d\u0167\u0171\u017b\u0181")
        buf.write("\u018b\u0191\u019b\u01a1\u01ab\u01b1\u01b4\u01bb\u01c2")
        buf.write("\u01c6\u01c9\u01d2\u01d8\u01e2\u01ef\u01f5\u01fa\u0201")
        buf.write("\u0206\u020d\u0214\u021b\u0222\u0227\u022d\u0233\u023f")
        buf.write("\u0246\u0250\u0253\u0261\u0267\u026e\u0274\u0279\u0281")
        buf.write("\u028a\u028f\u0294\u0296\u029b\u02a4\u02a8\u02ac\u02b0")
        buf.write("\u02b3\u02bb\u02bd\u02c4\u02d0")
        return buf.getvalue()


class DParser ( Parser ):

    grammarFileName = "DParser.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "<INVALID>", "<INVALID>", "'*/'", "<INVALID>", 
                     "'BEGIN'", "'END'", "'IF'", "'UNLESS'", "'WEIGHT'", 
                     "'THEN'", "'='", "'=='", "'BRANCH'", "'+'", "'COPY_TRANS'", 
                     "'COPY_TRANS_LATE'", "'DO'", "'JOURNAL'", "'SOLVED_JOURNAL'", 
                     "'UNSOLVED_JOURNAL'", "'FLAGS'", "'GOTO'", "'APPENDI'", 
                     "'CHAIN2'", "'SAFE'", "'EXTERN'", "'REPLY'", "'EXIT'", 
                     "'SAY'", "'IF_FILE_EXISTS'", "'('", "')'", "'AT'", 
                     "'APPEND'", "'APPEND_EARLY'", "<INVALID>", "'INTERJECT'", 
                     "'EXTEND_TOP'", "<INVALID>", "<INVALID>", "'ADD_TRANS_ACTION'", 
                     "'REPLACE_TRANS_ACTION'", "'REPLACE_TRANS_TRIGGER'", 
                     "'ALTER_TRANS'", "'REPLACE'", "'SET_WEIGHT'", "<INVALID>", 
                     "<INVALID>", "'REPLACE_TRIGGER_TEXT_REGEXP'", "<INVALID>", 
                     "'REPLACE_ACTION_TEXT_REGEXP'", "'REPLACE_ACTION_TEXT_PROCESS'", 
                     "<INVALID>", "'REPLACE_SAY'", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "'^'" ]

    symbolicNames = [ "<INVALID>", "WHITESPACE", "LINE_COMMENT", "BLOCK_COMMENT_END", 
                      "UNTERMINATED_BLOCK_COMMENT", "BEGIN", "END", "IF", 
                      "UNLESS", "WEIGHT", "THEN", "EQ", "EQEQ", "BRANCH", 
                      "PLUS", "COPY_TRANS", "COPY_TRANS_LATE", "DO", "JOURNAL", 
                      "SOLVED_JOURNAL", "UNSOLVED_JOURNAL", "FLAGS", "GOTO", 
                      "APPENDI", "CHAIN2", "SAFE", "EXTERN", "REPLY", "EXIT", 
                      "SAY", "IF_FILE_EXISTS", "PAREN_OPEN", "PAREN_CLOSE", 
                      "AT", "APPEND", "APPEND_EARLY", "CHAIN", "INTERJECT", 
                      "EXTEND_TOP", "ADD_STATE_TRIGGER", "ADD_TRANS_TRIGGER", 
                      "ADD_TRANS_ACTION", "REPLACE_TRANS_ACTION", "REPLACE_TRANS_TRIGGER", 
                      "ALTER_TRANS", "REPLACE", "SET_WEIGHT", "REPLACE_STATE_TRIGGER", 
                      "REPLACE_TRIGGER_TEXT", "REPLACE_TRIGGER_TEXT_REGEXP", 
                      "REPLACE_ACTION_TEXT", "REPLACE_ACTION_TEXT_REGEXP", 
                      "REPLACE_ACTION_TEXT_PROCESS", "REPLACE_ACTION_TEXT_PROCESS_REGEXP", 
                      "REPLACE_SAY", "EXTEND_BOTTOM", "INTERJECT_COPY_TRANS", 
                      "INTERJECT_COPY_TRANS2", "INTERJECT_COPY_TRANS3", 
                      "INTERJECT_COPY_TRANS4", "IDENTIFIER", "SHARP_NUMBER", 
                      "SOUND_STRING", "TILDE_STRING", "QUOTE_STRING", "PERCENT_STRING", 
                      "FORCED_STRING_REFERENCE", "TRANSLATION_REFERENCE", 
                      "CONCAT", "LONG_TILDE_STRING", "LONG_TILDE_STRING_UNTERMINATED", 
                      "BLOCK_COMMENT_START", "LONG_TILDE_STRING_START" ]

    RULE_dFileRule = 0
    RULE_dActionRule = 1
    RULE_alterTransCommand = 2
    RULE_conditionRule = 3
    RULE_stateRule = 4
    RULE_chain2DlgRule = 5
    RULE_chain2ElementRule = 6
    RULE_transitionRule = 7
    RULE_transitionTargetRule = 8
    RULE_chainActionEpilogRule = 9
    RULE_transitionFeatureRule = 10
    RULE_chainDlgRule = 11
    RULE_chainBlockRule = 12
    RULE_chainElementRule = 13
    RULE_fileRule = 14
    RULE_sayTextRule = 15
    RULE_traLineRule = 16
    RULE_dlgLineRule = 17
    RULE_stringRule = 18
    RULE_stringLiteralRule = 19
    RULE_identifierRule = 20
    RULE_referenceRule = 21
    RULE_sharpNumberRule = 22
    RULE_soundRule = 23

    ruleNames =  [ "dFileRule", "dActionRule", "alterTransCommand", "conditionRule", 
                   "stateRule", "chain2DlgRule", "chain2ElementRule", "transitionRule", 
                   "transitionTargetRule", "chainActionEpilogRule", "transitionFeatureRule", 
                   "chainDlgRule", "chainBlockRule", "chainElementRule", 
                   "fileRule", "sayTextRule", "traLineRule", "dlgLineRule", 
                   "stringRule", "stringLiteralRule", "identifierRule", 
                   "referenceRule", "sharpNumberRule", "soundRule" ]

    EOF = Token.EOF
    WHITESPACE=1
    LINE_COMMENT=2
    BLOCK_COMMENT_END=3
    UNTERMINATED_BLOCK_COMMENT=4
    BEGIN=5
    END=6
    IF=7
    UNLESS=8
    WEIGHT=9
    THEN=10
    EQ=11
    EQEQ=12
    BRANCH=13
    PLUS=14
    COPY_TRANS=15
    COPY_TRANS_LATE=16
    DO=17
    JOURNAL=18
    SOLVED_JOURNAL=19
    UNSOLVED_JOURNAL=20
    FLAGS=21
    GOTO=22
    APPENDI=23
    CHAIN2=24
    SAFE=25
    EXTERN=26
    REPLY=27
    EXIT=28
    SAY=29
    IF_FILE_EXISTS=30
    PAREN_OPEN=31
    PAREN_CLOSE=32
    AT=33
    APPEND=34
    APPEND_EARLY=35
    CHAIN=36
    INTERJECT=37
    EXTEND_TOP=38
    ADD_STATE_TRIGGER=39
    ADD_TRANS_TRIGGER=40
    ADD_TRANS_ACTION=41
    REPLACE_TRANS_ACTION=42
    REPLACE_TRANS_TRIGGER=43
    ALTER_TRANS=44
    REPLACE=45
    SET_WEIGHT=46
    REPLACE_STATE_TRIGGER=47
    REPLACE_TRIGGER_TEXT=48
    REPLACE_TRIGGER_TEXT_REGEXP=49
    REPLACE_ACTION_TEXT=50
    REPLACE_ACTION_TEXT_REGEXP=51
    REPLACE_ACTION_TEXT_PROCESS=52
    REPLACE_ACTION_TEXT_PROCESS_REGEXP=53
    REPLACE_SAY=54
    EXTEND_BOTTOM=55
    INTERJECT_COPY_TRANS=56
    INTERJECT_COPY_TRANS2=57
    INTERJECT_COPY_TRANS3=58
    INTERJECT_COPY_TRANS4=59
    IDENTIFIER=60
    SHARP_NUMBER=61
    SOUND_STRING=62
    TILDE_STRING=63
    QUOTE_STRING=64
    PERCENT_STRING=65
    FORCED_STRING_REFERENCE=66
    TRANSLATION_REFERENCE=67
    CONCAT=68
    LONG_TILDE_STRING=69
    LONG_TILDE_STRING_UNTERMINATED=70
    BLOCK_COMMENT_START=71
    LONG_TILDE_STRING_START=72

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.9.2")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class DFileRuleContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self._dActionRule = None # DActionRuleContext
            self.actions = list() # of DActionRuleContexts

        def EOF(self):
            return self.getToken(DParser.EOF, 0)

        def dActionRule(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(DParser.DActionRuleContext)
            else:
                return self.getTypedRuleContext(DParser.DActionRuleContext,i)


        def getRuleIndex(self):
            return DParser.RULE_dFileRule

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDFileRule" ):
                listener.enterDFileRule(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDFileRule" ):
                listener.exitDFileRule(self)




    def dFileRule(self):

        localctx = DParser.DFileRuleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_dFileRule)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 51
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << DParser.BEGIN) | (1 << DParser.APPEND) | (1 << DParser.APPEND_EARLY) | (1 << DParser.CHAIN) | (1 << DParser.INTERJECT) | (1 << DParser.EXTEND_TOP) | (1 << DParser.ADD_STATE_TRIGGER) | (1 << DParser.ADD_TRANS_TRIGGER) | (1 << DParser.ADD_TRANS_ACTION) | (1 << DParser.REPLACE_TRANS_ACTION) | (1 << DParser.REPLACE_TRANS_TRIGGER) | (1 << DParser.ALTER_TRANS) | (1 << DParser.REPLACE) | (1 << DParser.SET_WEIGHT) | (1 << DParser.REPLACE_STATE_TRIGGER) | (1 << DParser.REPLACE_TRIGGER_TEXT) | (1 << DParser.REPLACE_TRIGGER_TEXT_REGEXP) | (1 << DParser.REPLACE_ACTION_TEXT) | (1 << DParser.REPLACE_ACTION_TEXT_REGEXP) | (1 << DParser.REPLACE_ACTION_TEXT_PROCESS) | (1 << DParser.REPLACE_ACTION_TEXT_PROCESS_REGEXP) | (1 << DParser.REPLACE_SAY) | (1 << DParser.EXTEND_BOTTOM) | (1 << DParser.INTERJECT_COPY_TRANS) | (1 << DParser.INTERJECT_COPY_TRANS2) | (1 << DParser.INTERJECT_COPY_TRANS3) | (1 << DParser.INTERJECT_COPY_TRANS4))) != 0):
                self.state = 48
                localctx._dActionRule = self.dActionRule()
                localctx.actions.append(localctx._dActionRule)
                self.state = 53
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 54
            self.match(DParser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DActionRuleContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return DParser.RULE_dActionRule

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class ExtendTopBottomDActionContext(DActionRuleContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a DParser.DActionRuleContext
            super().__init__(parser)
            self.top = None # Token
            self.bottom = None # Token
            self.dlg = None # FileRuleContext
            self._stringRule = None # StringRuleContext
            self.states = list() # of StringRuleContexts
            self.position = None # SharpNumberRuleContext
            self._transitionRule = None # TransitionRuleContext
            self.transitions = list() # of TransitionRuleContexts
            self.copyFrom(ctx)

        def END(self):
            return self.getToken(DParser.END, 0)
        def fileRule(self):
            return self.getTypedRuleContext(DParser.FileRuleContext,0)

        def EXTEND_TOP(self):
            return self.getToken(DParser.EXTEND_TOP, 0)
        def EXTEND_BOTTOM(self):
            return self.getToken(DParser.EXTEND_BOTTOM, 0)
        def stringRule(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(DParser.StringRuleContext)
            else:
                return self.getTypedRuleContext(DParser.StringRuleContext,i)

        def sharpNumberRule(self):
            return self.getTypedRuleContext(DParser.SharpNumberRuleContext,0)

        def transitionRule(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(DParser.TransitionRuleContext)
            else:
                return self.getTypedRuleContext(DParser.TransitionRuleContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExtendTopBottomDAction" ):
                listener.enterExtendTopBottomDAction(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExtendTopBottomDAction" ):
                listener.exitExtendTopBottomDAction(self)


    class ReplaceDActionContext(DActionRuleContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a DParser.DActionRuleContext
            super().__init__(parser)
            self.dlg = None # FileRuleContext
            self._stateRule = None # StateRuleContext
            self.newStates = list() # of StateRuleContexts
            self.copyFrom(ctx)

        def REPLACE(self):
            return self.getToken(DParser.REPLACE, 0)
        def END(self):
            return self.getToken(DParser.END, 0)
        def fileRule(self):
            return self.getTypedRuleContext(DParser.FileRuleContext,0)

        def stateRule(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(DParser.StateRuleContext)
            else:
                return self.getTypedRuleContext(DParser.StateRuleContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterReplaceDAction" ):
                listener.enterReplaceDAction(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitReplaceDAction" ):
                listener.exitReplaceDAction(self)


    class AddStateTriggerDActionContext(DActionRuleContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a DParser.DActionRuleContext
            super().__init__(parser)
            self.dlg = None # FileRuleContext
            self._stringRule = None # StringRuleContext
            self.labels = list() # of StringRuleContexts
            self.trigger = None # StringRuleContext
            self._conditionRule = None # ConditionRuleContext
            self.conditions = list() # of ConditionRuleContexts
            self.copyFrom(ctx)

        def ADD_STATE_TRIGGER(self):
            return self.getToken(DParser.ADD_STATE_TRIGGER, 0)
        def fileRule(self):
            return self.getTypedRuleContext(DParser.FileRuleContext,0)

        def stringRule(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(DParser.StringRuleContext)
            else:
                return self.getTypedRuleContext(DParser.StringRuleContext,i)

        def conditionRule(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(DParser.ConditionRuleContext)
            else:
                return self.getTypedRuleContext(DParser.ConditionRuleContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAddStateTriggerDAction" ):
                listener.enterAddStateTriggerDAction(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAddStateTriggerDAction" ):
                listener.exitAddStateTriggerDAction(self)


    class AddTransTriggerDActionContext(DActionRuleContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a DParser.DActionRuleContext
            super().__init__(parser)
            self.dlg = None # FileRuleContext
            self._stringRule = None # StringRuleContext
            self.labels = list() # of StringRuleContexts
            self.trigger = None # StringRuleContext
            self.tras = list() # of StringRuleContexts
            self._conditionRule = None # ConditionRuleContext
            self.conditions = list() # of ConditionRuleContexts
            self.copyFrom(ctx)

        def ADD_TRANS_TRIGGER(self):
            return self.getToken(DParser.ADD_TRANS_TRIGGER, 0)
        def fileRule(self):
            return self.getTypedRuleContext(DParser.FileRuleContext,0)

        def stringRule(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(DParser.StringRuleContext)
            else:
                return self.getTypedRuleContext(DParser.StringRuleContext,i)

        def DO(self):
            return self.getToken(DParser.DO, 0)
        def conditionRule(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(DParser.ConditionRuleContext)
            else:
                return self.getTypedRuleContext(DParser.ConditionRuleContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAddTransTriggerDAction" ):
                listener.enterAddTransTriggerDAction(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAddTransTriggerDAction" ):
                listener.exitAddTransTriggerDAction(self)


    class ReplaceTransActionDActionContext(DActionRuleContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a DParser.DActionRuleContext
            super().__init__(parser)
            self.dlg = None # FileRuleContext
            self._stringRule = None # StringRuleContext
            self.labels = list() # of StringRuleContexts
            self.tras = list() # of StringRuleContexts
            self.oldText = None # StringRuleContext
            self.newText = None # StringRuleContext
            self._conditionRule = None # ConditionRuleContext
            self.conditions = list() # of ConditionRuleContexts
            self.copyFrom(ctx)

        def REPLACE_TRANS_ACTION(self):
            return self.getToken(DParser.REPLACE_TRANS_ACTION, 0)
        def BEGIN(self, i:int=None):
            if i is None:
                return self.getTokens(DParser.BEGIN)
            else:
                return self.getToken(DParser.BEGIN, i)
        def END(self, i:int=None):
            if i is None:
                return self.getTokens(DParser.END)
            else:
                return self.getToken(DParser.END, i)
        def fileRule(self):
            return self.getTypedRuleContext(DParser.FileRuleContext,0)

        def stringRule(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(DParser.StringRuleContext)
            else:
                return self.getTypedRuleContext(DParser.StringRuleContext,i)

        def conditionRule(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(DParser.ConditionRuleContext)
            else:
                return self.getTypedRuleContext(DParser.ConditionRuleContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterReplaceTransActionDAction" ):
                listener.enterReplaceTransActionDAction(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitReplaceTransActionDAction" ):
                listener.exitReplaceTransActionDAction(self)


    class ReplaceActionTextDActionContext(DActionRuleContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a DParser.DActionRuleContext
            super().__init__(parser)
            self._fileRule = None # FileRuleContext
            self.dlgs = list() # of FileRuleContexts
            self.oldText = None # StringRuleContext
            self.newText = None # StringRuleContext
            self._conditionRule = None # ConditionRuleContext
            self.conditions = list() # of ConditionRuleContexts
            self.copyFrom(ctx)

        def REPLACE_ACTION_TEXT(self):
            return self.getToken(DParser.REPLACE_ACTION_TEXT, 0)
        def fileRule(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(DParser.FileRuleContext)
            else:
                return self.getTypedRuleContext(DParser.FileRuleContext,i)

        def stringRule(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(DParser.StringRuleContext)
            else:
                return self.getTypedRuleContext(DParser.StringRuleContext,i)

        def conditionRule(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(DParser.ConditionRuleContext)
            else:
                return self.getTypedRuleContext(DParser.ConditionRuleContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterReplaceActionTextDAction" ):
                listener.enterReplaceActionTextDAction(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitReplaceActionTextDAction" ):
                listener.exitReplaceActionTextDAction(self)


    class AlterTransDActionContext(DActionRuleContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a DParser.DActionRuleContext
            super().__init__(parser)
            self.dlg = None # FileRuleContext
            self._stringRule = None # StringRuleContext
            self.labels = list() # of StringRuleContexts
            self.tras = list() # of StringRuleContexts
            self._alterTransCommand = None # AlterTransCommandContext
            self.changes = list() # of AlterTransCommandContexts
            self.copyFrom(ctx)

        def ALTER_TRANS(self):
            return self.getToken(DParser.ALTER_TRANS, 0)
        def BEGIN(self, i:int=None):
            if i is None:
                return self.getTokens(DParser.BEGIN)
            else:
                return self.getToken(DParser.BEGIN, i)
        def END(self, i:int=None):
            if i is None:
                return self.getTokens(DParser.END)
            else:
                return self.getToken(DParser.END, i)
        def fileRule(self):
            return self.getTypedRuleContext(DParser.FileRuleContext,0)

        def stringRule(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(DParser.StringRuleContext)
            else:
                return self.getTypedRuleContext(DParser.StringRuleContext,i)

        def alterTransCommand(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(DParser.AlterTransCommandContext)
            else:
                return self.getTypedRuleContext(DParser.AlterTransCommandContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAlterTransDAction" ):
                listener.enterAlterTransDAction(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAlterTransDAction" ):
                listener.exitAlterTransDAction(self)


    class BeginDActionContext(DActionRuleContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a DParser.DActionRuleContext
            super().__init__(parser)
            self.dlg = None # FileRuleContext
            self.nonPausing = None # StringRuleContext
            self._stateRule = None # StateRuleContext
            self.states = list() # of StateRuleContexts
            self.copyFrom(ctx)

        def BEGIN(self):
            return self.getToken(DParser.BEGIN, 0)
        def fileRule(self):
            return self.getTypedRuleContext(DParser.FileRuleContext,0)

        def stringRule(self):
            return self.getTypedRuleContext(DParser.StringRuleContext,0)

        def stateRule(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(DParser.StateRuleContext)
            else:
                return self.getTypedRuleContext(DParser.StateRuleContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBeginDAction" ):
                listener.enterBeginDAction(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBeginDAction" ):
                listener.exitBeginDAction(self)


    class ChainDActionContext(DActionRuleContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a DParser.DActionRuleContext
            super().__init__(parser)
            self.weight = None # SharpNumberRuleContext
            self.trigger = None # StringRuleContext
            self.ifExists = None # Token
            self.dlg = None # FileRuleContext
            self.label = None # StringRuleContext
            self.body = None # ChainDlgRuleContext
            self.epilog = None # ChainActionEpilogRuleContext
            self.copyFrom(ctx)

        def CHAIN(self):
            return self.getToken(DParser.CHAIN, 0)
        def fileRule(self):
            return self.getTypedRuleContext(DParser.FileRuleContext,0)

        def stringRule(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(DParser.StringRuleContext)
            else:
                return self.getTypedRuleContext(DParser.StringRuleContext,i)

        def chainDlgRule(self):
            return self.getTypedRuleContext(DParser.ChainDlgRuleContext,0)

        def chainActionEpilogRule(self):
            return self.getTypedRuleContext(DParser.ChainActionEpilogRuleContext,0)

        def IF(self):
            return self.getToken(DParser.IF, 0)
        def THEN(self):
            return self.getToken(DParser.THEN, 0)
        def IF_FILE_EXISTS(self):
            return self.getToken(DParser.IF_FILE_EXISTS, 0)
        def WEIGHT(self):
            return self.getToken(DParser.WEIGHT, 0)
        def sharpNumberRule(self):
            return self.getTypedRuleContext(DParser.SharpNumberRuleContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterChainDAction" ):
                listener.enterChainDAction(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitChainDAction" ):
                listener.exitChainDAction(self)


    class ReplaceActionTextProcessRegexpDActionContext(DActionRuleContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a DParser.DActionRuleContext
            super().__init__(parser)
            self._stringRule = None # StringRuleContext
            self.dlgRegexps = list() # of StringRuleContexts
            self.oldText = None # StringRuleContext
            self.newText = None # StringRuleContext
            self._conditionRule = None # ConditionRuleContext
            self.conditions = list() # of ConditionRuleContexts
            self.copyFrom(ctx)

        def REPLACE_ACTION_TEXT_PROCESS_REGEXP(self):
            return self.getToken(DParser.REPLACE_ACTION_TEXT_PROCESS_REGEXP, 0)
        def stringRule(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(DParser.StringRuleContext)
            else:
                return self.getTypedRuleContext(DParser.StringRuleContext,i)

        def conditionRule(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(DParser.ConditionRuleContext)
            else:
                return self.getTypedRuleContext(DParser.ConditionRuleContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterReplaceActionTextProcessRegexpDAction" ):
                listener.enterReplaceActionTextProcessRegexpDAction(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitReplaceActionTextProcessRegexpDAction" ):
                listener.exitReplaceActionTextProcessRegexpDAction(self)


    class ReplaceTriggerTextRegexpDActionContext(DActionRuleContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a DParser.DActionRuleContext
            super().__init__(parser)
            self.dlgRegexp = None # StringRuleContext
            self.oldText = None # StringRuleContext
            self.newText = None # StringRuleContext
            self._conditionRule = None # ConditionRuleContext
            self.conditions = list() # of ConditionRuleContexts
            self.copyFrom(ctx)

        def REPLACE_TRIGGER_TEXT_REGEXP(self):
            return self.getToken(DParser.REPLACE_TRIGGER_TEXT_REGEXP, 0)
        def stringRule(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(DParser.StringRuleContext)
            else:
                return self.getTypedRuleContext(DParser.StringRuleContext,i)

        def conditionRule(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(DParser.ConditionRuleContext)
            else:
                return self.getTypedRuleContext(DParser.ConditionRuleContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterReplaceTriggerTextRegexpDAction" ):
                listener.enterReplaceTriggerTextRegexpDAction(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitReplaceTriggerTextRegexpDAction" ):
                listener.exitReplaceTriggerTextRegexpDAction(self)


    class AppendEarlyDActionContext(DActionRuleContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a DParser.DActionRuleContext
            super().__init__(parser)
            self.ifExists = None # Token
            self.dlg = None # FileRuleContext
            self._stateRule = None # StateRuleContext
            self.states = list() # of StateRuleContexts
            self.copyFrom(ctx)

        def APPEND_EARLY(self):
            return self.getToken(DParser.APPEND_EARLY, 0)
        def END(self):
            return self.getToken(DParser.END, 0)
        def fileRule(self):
            return self.getTypedRuleContext(DParser.FileRuleContext,0)

        def IF_FILE_EXISTS(self):
            return self.getToken(DParser.IF_FILE_EXISTS, 0)
        def stateRule(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(DParser.StateRuleContext)
            else:
                return self.getTypedRuleContext(DParser.StateRuleContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAppendEarlyDAction" ):
                listener.enterAppendEarlyDAction(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAppendEarlyDAction" ):
                listener.exitAppendEarlyDAction(self)


    class ReplaceTriggerTextDActionContext(DActionRuleContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a DParser.DActionRuleContext
            super().__init__(parser)
            self.dlg = None # FileRuleContext
            self.oldText = None # StringRuleContext
            self.newText = None # StringRuleContext
            self._conditionRule = None # ConditionRuleContext
            self.conditions = list() # of ConditionRuleContexts
            self.copyFrom(ctx)

        def REPLACE_TRIGGER_TEXT(self):
            return self.getToken(DParser.REPLACE_TRIGGER_TEXT, 0)
        def fileRule(self):
            return self.getTypedRuleContext(DParser.FileRuleContext,0)

        def stringRule(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(DParser.StringRuleContext)
            else:
                return self.getTypedRuleContext(DParser.StringRuleContext,i)

        def conditionRule(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(DParser.ConditionRuleContext)
            else:
                return self.getTypedRuleContext(DParser.ConditionRuleContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterReplaceTriggerTextDAction" ):
                listener.enterReplaceTriggerTextDAction(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitReplaceTriggerTextDAction" ):
                listener.exitReplaceTriggerTextDAction(self)


    class AddTransActionDActionContext(DActionRuleContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a DParser.DActionRuleContext
            super().__init__(parser)
            self.dlg = None # FileRuleContext
            self._stringRule = None # StringRuleContext
            self.labels = list() # of StringRuleContexts
            self.tras = list() # of StringRuleContexts
            self.action = None # StringRuleContext
            self._conditionRule = None # ConditionRuleContext
            self.conditions = list() # of ConditionRuleContexts
            self.copyFrom(ctx)

        def ADD_TRANS_ACTION(self):
            return self.getToken(DParser.ADD_TRANS_ACTION, 0)
        def BEGIN(self, i:int=None):
            if i is None:
                return self.getTokens(DParser.BEGIN)
            else:
                return self.getToken(DParser.BEGIN, i)
        def END(self, i:int=None):
            if i is None:
                return self.getTokens(DParser.END)
            else:
                return self.getToken(DParser.END, i)
        def fileRule(self):
            return self.getTypedRuleContext(DParser.FileRuleContext,0)

        def stringRule(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(DParser.StringRuleContext)
            else:
                return self.getTypedRuleContext(DParser.StringRuleContext,i)

        def conditionRule(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(DParser.ConditionRuleContext)
            else:
                return self.getTypedRuleContext(DParser.ConditionRuleContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAddTransActionDAction" ):
                listener.enterAddTransActionDAction(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAddTransActionDAction" ):
                listener.exitAddTransActionDAction(self)


    class ReplaceTransTriggerDActionContext(DActionRuleContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a DParser.DActionRuleContext
            super().__init__(parser)
            self.dlg = None # FileRuleContext
            self._stringRule = None # StringRuleContext
            self.labels = list() # of StringRuleContexts
            self.tras = list() # of StringRuleContexts
            self.oldText = None # StringRuleContext
            self.newText = None # StringRuleContext
            self._conditionRule = None # ConditionRuleContext
            self.conditions = list() # of ConditionRuleContexts
            self.copyFrom(ctx)

        def REPLACE_TRANS_TRIGGER(self):
            return self.getToken(DParser.REPLACE_TRANS_TRIGGER, 0)
        def BEGIN(self, i:int=None):
            if i is None:
                return self.getTokens(DParser.BEGIN)
            else:
                return self.getToken(DParser.BEGIN, i)
        def END(self, i:int=None):
            if i is None:
                return self.getTokens(DParser.END)
            else:
                return self.getToken(DParser.END, i)
        def fileRule(self):
            return self.getTypedRuleContext(DParser.FileRuleContext,0)

        def stringRule(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(DParser.StringRuleContext)
            else:
                return self.getTypedRuleContext(DParser.StringRuleContext,i)

        def conditionRule(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(DParser.ConditionRuleContext)
            else:
                return self.getTypedRuleContext(DParser.ConditionRuleContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterReplaceTransTriggerDAction" ):
                listener.enterReplaceTransTriggerDAction(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitReplaceTransTriggerDAction" ):
                listener.exitReplaceTransTriggerDAction(self)


    class ReplaceActionTextProcessDActionContext(DActionRuleContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a DParser.DActionRuleContext
            super().__init__(parser)
            self._fileRule = None # FileRuleContext
            self.dlgs = list() # of FileRuleContexts
            self.oldText = None # StringRuleContext
            self.newText = None # StringRuleContext
            self._conditionRule = None # ConditionRuleContext
            self.conditions = list() # of ConditionRuleContexts
            self.copyFrom(ctx)

        def REPLACE_ACTION_TEXT_PROCESS(self):
            return self.getToken(DParser.REPLACE_ACTION_TEXT_PROCESS, 0)
        def fileRule(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(DParser.FileRuleContext)
            else:
                return self.getTypedRuleContext(DParser.FileRuleContext,i)

        def stringRule(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(DParser.StringRuleContext)
            else:
                return self.getTypedRuleContext(DParser.StringRuleContext,i)

        def conditionRule(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(DParser.ConditionRuleContext)
            else:
                return self.getTypedRuleContext(DParser.ConditionRuleContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterReplaceActionTextProcessDAction" ):
                listener.enterReplaceActionTextProcessDAction(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitReplaceActionTextProcessDAction" ):
                listener.exitReplaceActionTextProcessDAction(self)


    class InterjectCopyTransDActionContext(DActionRuleContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a DParser.DActionRuleContext
            super().__init__(parser)
            self.v1 = None # Token
            self.v2 = None # Token
            self.v3 = None # Token
            self.v4 = None # Token
            self.safe = None # Token
            self.ifExists = None # Token
            self.dlg = None # FileRuleContext
            self.label = None # StringRuleContext
            self.globalVar = None # StringRuleContext
            self._chainBlockRule = None # ChainBlockRuleContext
            self.blocks = list() # of ChainBlockRuleContexts
            self.copyFrom(ctx)

        def END(self):
            return self.getToken(DParser.END, 0)
        def fileRule(self):
            return self.getTypedRuleContext(DParser.FileRuleContext,0)

        def stringRule(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(DParser.StringRuleContext)
            else:
                return self.getTypedRuleContext(DParser.StringRuleContext,i)

        def INTERJECT_COPY_TRANS(self):
            return self.getToken(DParser.INTERJECT_COPY_TRANS, 0)
        def INTERJECT_COPY_TRANS2(self):
            return self.getToken(DParser.INTERJECT_COPY_TRANS2, 0)
        def INTERJECT_COPY_TRANS3(self):
            return self.getToken(DParser.INTERJECT_COPY_TRANS3, 0)
        def INTERJECT_COPY_TRANS4(self):
            return self.getToken(DParser.INTERJECT_COPY_TRANS4, 0)
        def SAFE(self):
            return self.getToken(DParser.SAFE, 0)
        def IF_FILE_EXISTS(self):
            return self.getToken(DParser.IF_FILE_EXISTS, 0)
        def chainBlockRule(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(DParser.ChainBlockRuleContext)
            else:
                return self.getTypedRuleContext(DParser.ChainBlockRuleContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInterjectCopyTransDAction" ):
                listener.enterInterjectCopyTransDAction(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInterjectCopyTransDAction" ):
                listener.exitInterjectCopyTransDAction(self)


    class ReplaceStateTriggerDActionContext(DActionRuleContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a DParser.DActionRuleContext
            super().__init__(parser)
            self.dlg = None # FileRuleContext
            self._stringRule = None # StringRuleContext
            self.labels = list() # of StringRuleContexts
            self.trigger = None # StringRuleContext
            self._conditionRule = None # ConditionRuleContext
            self.conditions = list() # of ConditionRuleContexts
            self.copyFrom(ctx)

        def REPLACE_STATE_TRIGGER(self):
            return self.getToken(DParser.REPLACE_STATE_TRIGGER, 0)
        def fileRule(self):
            return self.getTypedRuleContext(DParser.FileRuleContext,0)

        def stringRule(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(DParser.StringRuleContext)
            else:
                return self.getTypedRuleContext(DParser.StringRuleContext,i)

        def conditionRule(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(DParser.ConditionRuleContext)
            else:
                return self.getTypedRuleContext(DParser.ConditionRuleContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterReplaceStateTriggerDAction" ):
                listener.enterReplaceStateTriggerDAction(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitReplaceStateTriggerDAction" ):
                listener.exitReplaceStateTriggerDAction(self)


    class ReplaceSayDActionContext(DActionRuleContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a DParser.DActionRuleContext
            super().__init__(parser)
            self.dlg = None # FileRuleContext
            self.label = None # StringRuleContext
            self.newVal = None # SayTextRuleContext
            self.copyFrom(ctx)

        def REPLACE_SAY(self):
            return self.getToken(DParser.REPLACE_SAY, 0)
        def fileRule(self):
            return self.getTypedRuleContext(DParser.FileRuleContext,0)

        def stringRule(self):
            return self.getTypedRuleContext(DParser.StringRuleContext,0)

        def sayTextRule(self):
            return self.getTypedRuleContext(DParser.SayTextRuleContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterReplaceSayDAction" ):
                listener.enterReplaceSayDAction(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitReplaceSayDAction" ):
                listener.exitReplaceSayDAction(self)


    class InterjectDActionContext(DActionRuleContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a DParser.DActionRuleContext
            super().__init__(parser)
            self.dlg = None # FileRuleContext
            self.label = None # StringRuleContext
            self.globalVar = None # StringRuleContext
            self._chainBlockRule = None # ChainBlockRuleContext
            self.blocks = list() # of ChainBlockRuleContexts
            self.epilog = None # ChainActionEpilogRuleContext
            self.copyFrom(ctx)

        def INTERJECT(self):
            return self.getToken(DParser.INTERJECT, 0)
        def fileRule(self):
            return self.getTypedRuleContext(DParser.FileRuleContext,0)

        def stringRule(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(DParser.StringRuleContext)
            else:
                return self.getTypedRuleContext(DParser.StringRuleContext,i)

        def chainActionEpilogRule(self):
            return self.getTypedRuleContext(DParser.ChainActionEpilogRuleContext,0)

        def chainBlockRule(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(DParser.ChainBlockRuleContext)
            else:
                return self.getTypedRuleContext(DParser.ChainBlockRuleContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInterjectDAction" ):
                listener.enterInterjectDAction(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInterjectDAction" ):
                listener.exitInterjectDAction(self)


    class ReplaceActionTextRegexpDActionContext(DActionRuleContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a DParser.DActionRuleContext
            super().__init__(parser)
            self._stringRule = None # StringRuleContext
            self.dlgRegexps = list() # of StringRuleContexts
            self.oldText = None # StringRuleContext
            self.newText = None # StringRuleContext
            self._conditionRule = None # ConditionRuleContext
            self.conditions = list() # of ConditionRuleContexts
            self.copyFrom(ctx)

        def REPLACE_ACTION_TEXT_REGEXP(self):
            return self.getToken(DParser.REPLACE_ACTION_TEXT_REGEXP, 0)
        def stringRule(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(DParser.StringRuleContext)
            else:
                return self.getTypedRuleContext(DParser.StringRuleContext,i)

        def conditionRule(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(DParser.ConditionRuleContext)
            else:
                return self.getTypedRuleContext(DParser.ConditionRuleContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterReplaceActionTextRegexpDAction" ):
                listener.enterReplaceActionTextRegexpDAction(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitReplaceActionTextRegexpDAction" ):
                listener.exitReplaceActionTextRegexpDAction(self)


    class AppendDActionContext(DActionRuleContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a DParser.DActionRuleContext
            super().__init__(parser)
            self.ifExists = None # Token
            self.dlg = None # FileRuleContext
            self._stateRule = None # StateRuleContext
            self.states = list() # of StateRuleContexts
            self.copyFrom(ctx)

        def APPEND(self):
            return self.getToken(DParser.APPEND, 0)
        def END(self):
            return self.getToken(DParser.END, 0)
        def fileRule(self):
            return self.getTypedRuleContext(DParser.FileRuleContext,0)

        def IF_FILE_EXISTS(self):
            return self.getToken(DParser.IF_FILE_EXISTS, 0)
        def stateRule(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(DParser.StateRuleContext)
            else:
                return self.getTypedRuleContext(DParser.StateRuleContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAppendDAction" ):
                listener.enterAppendDAction(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAppendDAction" ):
                listener.exitAppendDAction(self)


    class SetWeightDActionContext(DActionRuleContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a DParser.DActionRuleContext
            super().__init__(parser)
            self.dlg = None # FileRuleContext
            self.label = None # StringRuleContext
            self.weight = None # SharpNumberRuleContext
            self.copyFrom(ctx)

        def SET_WEIGHT(self):
            return self.getToken(DParser.SET_WEIGHT, 0)
        def fileRule(self):
            return self.getTypedRuleContext(DParser.FileRuleContext,0)

        def stringRule(self):
            return self.getTypedRuleContext(DParser.StringRuleContext,0)

        def sharpNumberRule(self):
            return self.getTypedRuleContext(DParser.SharpNumberRuleContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSetWeightDAction" ):
                listener.enterSetWeightDAction(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSetWeightDAction" ):
                listener.exitSetWeightDAction(self)



    def dActionRule(self):

        localctx = DParser.DActionRuleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_dActionRule)
        self._la = 0 # Token type
        try:
            self.state = 434
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [DParser.BEGIN]:
                localctx = DParser.BeginDActionContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 56
                self.match(DParser.BEGIN)
                self.state = 57
                localctx.dlg = self.fileRule()
                self.state = 59
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if ((((_la - 60)) & ~0x3f) == 0 and ((1 << (_la - 60)) & ((1 << (DParser.IDENTIFIER - 60)) | (1 << (DParser.TILDE_STRING - 60)) | (1 << (DParser.QUOTE_STRING - 60)) | (1 << (DParser.PERCENT_STRING - 60)) | (1 << (DParser.LONG_TILDE_STRING - 60)))) != 0):
                    self.state = 58
                    localctx.nonPausing = self.stringRule()


                self.state = 64
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << DParser.IF) | (1 << DParser.APPENDI) | (1 << DParser.CHAIN2))) != 0):
                    self.state = 61
                    localctx._stateRule = self.stateRule()
                    localctx.states.append(localctx._stateRule)
                    self.state = 66
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                pass
            elif token in [DParser.APPEND]:
                localctx = DParser.AppendDActionContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 67
                self.match(DParser.APPEND)
                self.state = 69
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==DParser.IF_FILE_EXISTS:
                    self.state = 68
                    localctx.ifExists = self.match(DParser.IF_FILE_EXISTS)


                self.state = 71
                localctx.dlg = self.fileRule()
                self.state = 75
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << DParser.IF) | (1 << DParser.APPENDI) | (1 << DParser.CHAIN2))) != 0):
                    self.state = 72
                    localctx._stateRule = self.stateRule()
                    localctx.states.append(localctx._stateRule)
                    self.state = 77
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 78
                self.match(DParser.END)
                pass
            elif token in [DParser.APPEND_EARLY]:
                localctx = DParser.AppendEarlyDActionContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 80
                self.match(DParser.APPEND_EARLY)
                self.state = 82
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==DParser.IF_FILE_EXISTS:
                    self.state = 81
                    localctx.ifExists = self.match(DParser.IF_FILE_EXISTS)


                self.state = 84
                localctx.dlg = self.fileRule()
                self.state = 88
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << DParser.IF) | (1 << DParser.APPENDI) | (1 << DParser.CHAIN2))) != 0):
                    self.state = 85
                    localctx._stateRule = self.stateRule()
                    localctx.states.append(localctx._stateRule)
                    self.state = 90
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 91
                self.match(DParser.END)
                pass
            elif token in [DParser.CHAIN]:
                localctx = DParser.ChainDActionContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 93
                self.match(DParser.CHAIN)
                self.state = 102
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==DParser.IF:
                    self.state = 94
                    self.match(DParser.IF)
                    self.state = 97
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==DParser.WEIGHT:
                        self.state = 95
                        self.match(DParser.WEIGHT)
                        self.state = 96
                        localctx.weight = self.sharpNumberRule()


                    self.state = 99
                    localctx.trigger = self.stringRule()
                    self.state = 100
                    self.match(DParser.THEN)


                self.state = 105
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==DParser.IF_FILE_EXISTS:
                    self.state = 104
                    localctx.ifExists = self.match(DParser.IF_FILE_EXISTS)


                self.state = 107
                localctx.dlg = self.fileRule()
                self.state = 108
                localctx.label = self.stringRule()
                self.state = 109
                localctx.body = self.chainDlgRule()
                self.state = 110
                localctx.epilog = self.chainActionEpilogRule()
                pass
            elif token in [DParser.INTERJECT]:
                localctx = DParser.InterjectDActionContext(self, localctx)
                self.enterOuterAlt(localctx, 5)
                self.state = 112
                self.match(DParser.INTERJECT)
                self.state = 113
                localctx.dlg = self.fileRule()
                self.state = 114
                localctx.label = self.stringRule()
                self.state = 115
                localctx.globalVar = self.stringRule()
                self.state = 119
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==DParser.EQEQ or _la==DParser.BRANCH:
                    self.state = 116
                    localctx._chainBlockRule = self.chainBlockRule()
                    localctx.blocks.append(localctx._chainBlockRule)
                    self.state = 121
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 122
                localctx.epilog = self.chainActionEpilogRule()
                pass
            elif token in [DParser.INTERJECT_COPY_TRANS, DParser.INTERJECT_COPY_TRANS2, DParser.INTERJECT_COPY_TRANS3, DParser.INTERJECT_COPY_TRANS4]:
                localctx = DParser.InterjectCopyTransDActionContext(self, localctx)
                self.enterOuterAlt(localctx, 6)
                self.state = 128
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [DParser.INTERJECT_COPY_TRANS]:
                    self.state = 124
                    localctx.v1 = self.match(DParser.INTERJECT_COPY_TRANS)
                    pass
                elif token in [DParser.INTERJECT_COPY_TRANS2]:
                    self.state = 125
                    localctx.v2 = self.match(DParser.INTERJECT_COPY_TRANS2)
                    pass
                elif token in [DParser.INTERJECT_COPY_TRANS3]:
                    self.state = 126
                    localctx.v3 = self.match(DParser.INTERJECT_COPY_TRANS3)
                    pass
                elif token in [DParser.INTERJECT_COPY_TRANS4]:
                    self.state = 127
                    localctx.v4 = self.match(DParser.INTERJECT_COPY_TRANS4)
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 131
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==DParser.SAFE:
                    self.state = 130
                    localctx.safe = self.match(DParser.SAFE)


                self.state = 134
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==DParser.IF_FILE_EXISTS:
                    self.state = 133
                    localctx.ifExists = self.match(DParser.IF_FILE_EXISTS)


                self.state = 136
                localctx.dlg = self.fileRule()
                self.state = 137
                localctx.label = self.stringRule()
                self.state = 138
                localctx.globalVar = self.stringRule()
                self.state = 142
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==DParser.EQEQ or _la==DParser.BRANCH:
                    self.state = 139
                    localctx._chainBlockRule = self.chainBlockRule()
                    localctx.blocks.append(localctx._chainBlockRule)
                    self.state = 144
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 145
                self.match(DParser.END)
                pass
            elif token in [DParser.EXTEND_TOP, DParser.EXTEND_BOTTOM]:
                localctx = DParser.ExtendTopBottomDActionContext(self, localctx)
                self.enterOuterAlt(localctx, 7)
                self.state = 149
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [DParser.EXTEND_TOP]:
                    self.state = 147
                    localctx.top = self.match(DParser.EXTEND_TOP)
                    pass
                elif token in [DParser.EXTEND_BOTTOM]:
                    self.state = 148
                    localctx.bottom = self.match(DParser.EXTEND_BOTTOM)
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 151
                localctx.dlg = self.fileRule()
                self.state = 155
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while ((((_la - 60)) & ~0x3f) == 0 and ((1 << (_la - 60)) & ((1 << (DParser.IDENTIFIER - 60)) | (1 << (DParser.TILDE_STRING - 60)) | (1 << (DParser.QUOTE_STRING - 60)) | (1 << (DParser.PERCENT_STRING - 60)) | (1 << (DParser.LONG_TILDE_STRING - 60)))) != 0):
                    self.state = 152
                    localctx._stringRule = self.stringRule()
                    localctx.states.append(localctx._stringRule)
                    self.state = 157
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 159
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==DParser.SHARP_NUMBER:
                    self.state = 158
                    localctx.position = self.sharpNumberRule()


                self.state = 164
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << DParser.IF) | (1 << DParser.PLUS) | (1 << DParser.COPY_TRANS) | (1 << DParser.COPY_TRANS_LATE))) != 0):
                    self.state = 161
                    localctx._transitionRule = self.transitionRule()
                    localctx.transitions.append(localctx._transitionRule)
                    self.state = 166
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 167
                self.match(DParser.END)
                pass
            elif token in [DParser.ADD_STATE_TRIGGER]:
                localctx = DParser.AddStateTriggerDActionContext(self, localctx)
                self.enterOuterAlt(localctx, 8)
                self.state = 169
                self.match(DParser.ADD_STATE_TRIGGER)
                self.state = 170
                localctx.dlg = self.fileRule()
                self.state = 171
                localctx._stringRule = self.stringRule()
                localctx.labels.append(localctx._stringRule)
                self.state = 172
                localctx.trigger = self.stringRule()
                self.state = 176
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while ((((_la - 60)) & ~0x3f) == 0 and ((1 << (_la - 60)) & ((1 << (DParser.IDENTIFIER - 60)) | (1 << (DParser.TILDE_STRING - 60)) | (1 << (DParser.QUOTE_STRING - 60)) | (1 << (DParser.PERCENT_STRING - 60)) | (1 << (DParser.LONG_TILDE_STRING - 60)))) != 0):
                    self.state = 173
                    localctx._stringRule = self.stringRule()
                    localctx.labels.append(localctx._stringRule)
                    self.state = 178
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 182
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==DParser.IF or _la==DParser.UNLESS:
                    self.state = 179
                    localctx._conditionRule = self.conditionRule()
                    localctx.conditions.append(localctx._conditionRule)
                    self.state = 184
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                pass
            elif token in [DParser.ADD_TRANS_TRIGGER]:
                localctx = DParser.AddTransTriggerDActionContext(self, localctx)
                self.enterOuterAlt(localctx, 9)
                self.state = 185
                self.match(DParser.ADD_TRANS_TRIGGER)
                self.state = 186
                localctx.dlg = self.fileRule()
                self.state = 187
                localctx._stringRule = self.stringRule()
                localctx.labels.append(localctx._stringRule)
                self.state = 188
                localctx.trigger = self.stringRule()
                self.state = 192
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while ((((_la - 60)) & ~0x3f) == 0 and ((1 << (_la - 60)) & ((1 << (DParser.IDENTIFIER - 60)) | (1 << (DParser.TILDE_STRING - 60)) | (1 << (DParser.QUOTE_STRING - 60)) | (1 << (DParser.PERCENT_STRING - 60)) | (1 << (DParser.LONG_TILDE_STRING - 60)))) != 0):
                    self.state = 189
                    localctx._stringRule = self.stringRule()
                    localctx.labels.append(localctx._stringRule)
                    self.state = 194
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 202
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==DParser.DO:
                    self.state = 195
                    self.match(DParser.DO)
                    self.state = 199
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    while ((((_la - 60)) & ~0x3f) == 0 and ((1 << (_la - 60)) & ((1 << (DParser.IDENTIFIER - 60)) | (1 << (DParser.TILDE_STRING - 60)) | (1 << (DParser.QUOTE_STRING - 60)) | (1 << (DParser.PERCENT_STRING - 60)) | (1 << (DParser.LONG_TILDE_STRING - 60)))) != 0):
                        self.state = 196
                        localctx._stringRule = self.stringRule()
                        localctx.tras.append(localctx._stringRule)
                        self.state = 201
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)



                self.state = 207
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==DParser.IF or _la==DParser.UNLESS:
                    self.state = 204
                    localctx._conditionRule = self.conditionRule()
                    localctx.conditions.append(localctx._conditionRule)
                    self.state = 209
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                pass
            elif token in [DParser.ADD_TRANS_ACTION]:
                localctx = DParser.AddTransActionDActionContext(self, localctx)
                self.enterOuterAlt(localctx, 10)
                self.state = 210
                self.match(DParser.ADD_TRANS_ACTION)
                self.state = 211
                localctx.dlg = self.fileRule()
                self.state = 212
                self.match(DParser.BEGIN)
                self.state = 216
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while ((((_la - 60)) & ~0x3f) == 0 and ((1 << (_la - 60)) & ((1 << (DParser.IDENTIFIER - 60)) | (1 << (DParser.TILDE_STRING - 60)) | (1 << (DParser.QUOTE_STRING - 60)) | (1 << (DParser.PERCENT_STRING - 60)) | (1 << (DParser.LONG_TILDE_STRING - 60)))) != 0):
                    self.state = 213
                    localctx._stringRule = self.stringRule()
                    localctx.labels.append(localctx._stringRule)
                    self.state = 218
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 219
                self.match(DParser.END)
                self.state = 220
                self.match(DParser.BEGIN)
                self.state = 224
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while ((((_la - 60)) & ~0x3f) == 0 and ((1 << (_la - 60)) & ((1 << (DParser.IDENTIFIER - 60)) | (1 << (DParser.TILDE_STRING - 60)) | (1 << (DParser.QUOTE_STRING - 60)) | (1 << (DParser.PERCENT_STRING - 60)) | (1 << (DParser.LONG_TILDE_STRING - 60)))) != 0):
                    self.state = 221
                    localctx._stringRule = self.stringRule()
                    localctx.tras.append(localctx._stringRule)
                    self.state = 226
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 227
                self.match(DParser.END)
                self.state = 228
                localctx.action = self.stringRule()
                self.state = 232
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==DParser.IF or _la==DParser.UNLESS:
                    self.state = 229
                    localctx._conditionRule = self.conditionRule()
                    localctx.conditions.append(localctx._conditionRule)
                    self.state = 234
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                pass
            elif token in [DParser.REPLACE_TRANS_ACTION]:
                localctx = DParser.ReplaceTransActionDActionContext(self, localctx)
                self.enterOuterAlt(localctx, 11)
                self.state = 235
                self.match(DParser.REPLACE_TRANS_ACTION)
                self.state = 236
                localctx.dlg = self.fileRule()
                self.state = 237
                self.match(DParser.BEGIN)
                self.state = 241
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while ((((_la - 60)) & ~0x3f) == 0 and ((1 << (_la - 60)) & ((1 << (DParser.IDENTIFIER - 60)) | (1 << (DParser.TILDE_STRING - 60)) | (1 << (DParser.QUOTE_STRING - 60)) | (1 << (DParser.PERCENT_STRING - 60)) | (1 << (DParser.LONG_TILDE_STRING - 60)))) != 0):
                    self.state = 238
                    localctx._stringRule = self.stringRule()
                    localctx.labels.append(localctx._stringRule)
                    self.state = 243
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 244
                self.match(DParser.END)
                self.state = 245
                self.match(DParser.BEGIN)
                self.state = 249
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while ((((_la - 60)) & ~0x3f) == 0 and ((1 << (_la - 60)) & ((1 << (DParser.IDENTIFIER - 60)) | (1 << (DParser.TILDE_STRING - 60)) | (1 << (DParser.QUOTE_STRING - 60)) | (1 << (DParser.PERCENT_STRING - 60)) | (1 << (DParser.LONG_TILDE_STRING - 60)))) != 0):
                    self.state = 246
                    localctx._stringRule = self.stringRule()
                    localctx.tras.append(localctx._stringRule)
                    self.state = 251
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 252
                self.match(DParser.END)
                self.state = 253
                localctx.oldText = self.stringRule()
                self.state = 254
                localctx.newText = self.stringRule()
                self.state = 258
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==DParser.IF or _la==DParser.UNLESS:
                    self.state = 255
                    localctx._conditionRule = self.conditionRule()
                    localctx.conditions.append(localctx._conditionRule)
                    self.state = 260
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                pass
            elif token in [DParser.REPLACE_TRANS_TRIGGER]:
                localctx = DParser.ReplaceTransTriggerDActionContext(self, localctx)
                self.enterOuterAlt(localctx, 12)
                self.state = 261
                self.match(DParser.REPLACE_TRANS_TRIGGER)
                self.state = 262
                localctx.dlg = self.fileRule()
                self.state = 263
                self.match(DParser.BEGIN)
                self.state = 267
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while ((((_la - 60)) & ~0x3f) == 0 and ((1 << (_la - 60)) & ((1 << (DParser.IDENTIFIER - 60)) | (1 << (DParser.TILDE_STRING - 60)) | (1 << (DParser.QUOTE_STRING - 60)) | (1 << (DParser.PERCENT_STRING - 60)) | (1 << (DParser.LONG_TILDE_STRING - 60)))) != 0):
                    self.state = 264
                    localctx._stringRule = self.stringRule()
                    localctx.labels.append(localctx._stringRule)
                    self.state = 269
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 270
                self.match(DParser.END)
                self.state = 271
                self.match(DParser.BEGIN)
                self.state = 275
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while ((((_la - 60)) & ~0x3f) == 0 and ((1 << (_la - 60)) & ((1 << (DParser.IDENTIFIER - 60)) | (1 << (DParser.TILDE_STRING - 60)) | (1 << (DParser.QUOTE_STRING - 60)) | (1 << (DParser.PERCENT_STRING - 60)) | (1 << (DParser.LONG_TILDE_STRING - 60)))) != 0):
                    self.state = 272
                    localctx._stringRule = self.stringRule()
                    localctx.tras.append(localctx._stringRule)
                    self.state = 277
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 278
                self.match(DParser.END)
                self.state = 279
                localctx.oldText = self.stringRule()
                self.state = 280
                localctx.newText = self.stringRule()
                self.state = 284
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==DParser.IF or _la==DParser.UNLESS:
                    self.state = 281
                    localctx._conditionRule = self.conditionRule()
                    localctx.conditions.append(localctx._conditionRule)
                    self.state = 286
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                pass
            elif token in [DParser.ALTER_TRANS]:
                localctx = DParser.AlterTransDActionContext(self, localctx)
                self.enterOuterAlt(localctx, 13)
                self.state = 287
                self.match(DParser.ALTER_TRANS)
                self.state = 288
                localctx.dlg = self.fileRule()
                self.state = 289
                self.match(DParser.BEGIN)
                self.state = 293
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while ((((_la - 60)) & ~0x3f) == 0 and ((1 << (_la - 60)) & ((1 << (DParser.IDENTIFIER - 60)) | (1 << (DParser.TILDE_STRING - 60)) | (1 << (DParser.QUOTE_STRING - 60)) | (1 << (DParser.PERCENT_STRING - 60)) | (1 << (DParser.LONG_TILDE_STRING - 60)))) != 0):
                    self.state = 290
                    localctx._stringRule = self.stringRule()
                    localctx.labels.append(localctx._stringRule)
                    self.state = 295
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 296
                self.match(DParser.END)
                self.state = 297
                self.match(DParser.BEGIN)
                self.state = 301
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while ((((_la - 60)) & ~0x3f) == 0 and ((1 << (_la - 60)) & ((1 << (DParser.IDENTIFIER - 60)) | (1 << (DParser.TILDE_STRING - 60)) | (1 << (DParser.QUOTE_STRING - 60)) | (1 << (DParser.PERCENT_STRING - 60)) | (1 << (DParser.LONG_TILDE_STRING - 60)))) != 0):
                    self.state = 298
                    localctx._stringRule = self.stringRule()
                    localctx.tras.append(localctx._stringRule)
                    self.state = 303
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 304
                self.match(DParser.END)
                self.state = 305
                self.match(DParser.BEGIN)
                self.state = 309
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while ((((_la - 60)) & ~0x3f) == 0 and ((1 << (_la - 60)) & ((1 << (DParser.IDENTIFIER - 60)) | (1 << (DParser.TILDE_STRING - 60)) | (1 << (DParser.QUOTE_STRING - 60)) | (1 << (DParser.PERCENT_STRING - 60)) | (1 << (DParser.LONG_TILDE_STRING - 60)))) != 0):
                    self.state = 306
                    localctx._alterTransCommand = self.alterTransCommand()
                    localctx.changes.append(localctx._alterTransCommand)
                    self.state = 311
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 312
                self.match(DParser.END)
                pass
            elif token in [DParser.REPLACE]:
                localctx = DParser.ReplaceDActionContext(self, localctx)
                self.enterOuterAlt(localctx, 14)
                self.state = 314
                self.match(DParser.REPLACE)
                self.state = 315
                localctx.dlg = self.fileRule()
                self.state = 319
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << DParser.IF) | (1 << DParser.APPENDI) | (1 << DParser.CHAIN2))) != 0):
                    self.state = 316
                    localctx._stateRule = self.stateRule()
                    localctx.newStates.append(localctx._stateRule)
                    self.state = 321
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 322
                self.match(DParser.END)
                pass
            elif token in [DParser.SET_WEIGHT]:
                localctx = DParser.SetWeightDActionContext(self, localctx)
                self.enterOuterAlt(localctx, 15)
                self.state = 324
                self.match(DParser.SET_WEIGHT)
                self.state = 325
                localctx.dlg = self.fileRule()
                self.state = 326
                localctx.label = self.stringRule()
                self.state = 327
                localctx.weight = self.sharpNumberRule()
                pass
            elif token in [DParser.REPLACE_SAY]:
                localctx = DParser.ReplaceSayDActionContext(self, localctx)
                self.enterOuterAlt(localctx, 16)
                self.state = 329
                self.match(DParser.REPLACE_SAY)
                self.state = 330
                localctx.dlg = self.fileRule()
                self.state = 331
                localctx.label = self.stringRule()
                self.state = 332
                localctx.newVal = self.sayTextRule()
                pass
            elif token in [DParser.REPLACE_STATE_TRIGGER]:
                localctx = DParser.ReplaceStateTriggerDActionContext(self, localctx)
                self.enterOuterAlt(localctx, 17)
                self.state = 334
                self.match(DParser.REPLACE_STATE_TRIGGER)
                self.state = 335
                localctx.dlg = self.fileRule()
                self.state = 336
                localctx._stringRule = self.stringRule()
                localctx.labels.append(localctx._stringRule)
                self.state = 337
                localctx.trigger = self.stringRule()
                self.state = 341
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while ((((_la - 60)) & ~0x3f) == 0 and ((1 << (_la - 60)) & ((1 << (DParser.IDENTIFIER - 60)) | (1 << (DParser.TILDE_STRING - 60)) | (1 << (DParser.QUOTE_STRING - 60)) | (1 << (DParser.PERCENT_STRING - 60)) | (1 << (DParser.LONG_TILDE_STRING - 60)))) != 0):
                    self.state = 338
                    localctx._stringRule = self.stringRule()
                    localctx.labels.append(localctx._stringRule)
                    self.state = 343
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 347
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==DParser.IF or _la==DParser.UNLESS:
                    self.state = 344
                    localctx._conditionRule = self.conditionRule()
                    localctx.conditions.append(localctx._conditionRule)
                    self.state = 349
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                pass
            elif token in [DParser.REPLACE_TRIGGER_TEXT]:
                localctx = DParser.ReplaceTriggerTextDActionContext(self, localctx)
                self.enterOuterAlt(localctx, 18)
                self.state = 350
                self.match(DParser.REPLACE_TRIGGER_TEXT)
                self.state = 351
                localctx.dlg = self.fileRule()
                self.state = 352
                localctx.oldText = self.stringRule()
                self.state = 353
                localctx.newText = self.stringRule()
                self.state = 357
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==DParser.IF or _la==DParser.UNLESS:
                    self.state = 354
                    localctx._conditionRule = self.conditionRule()
                    localctx.conditions.append(localctx._conditionRule)
                    self.state = 359
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                pass
            elif token in [DParser.REPLACE_TRIGGER_TEXT_REGEXP]:
                localctx = DParser.ReplaceTriggerTextRegexpDActionContext(self, localctx)
                self.enterOuterAlt(localctx, 19)
                self.state = 360
                self.match(DParser.REPLACE_TRIGGER_TEXT_REGEXP)
                self.state = 361
                localctx.dlgRegexp = self.stringRule()
                self.state = 362
                localctx.oldText = self.stringRule()
                self.state = 363
                localctx.newText = self.stringRule()
                self.state = 367
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==DParser.IF or _la==DParser.UNLESS:
                    self.state = 364
                    localctx._conditionRule = self.conditionRule()
                    localctx.conditions.append(localctx._conditionRule)
                    self.state = 369
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                pass
            elif token in [DParser.REPLACE_ACTION_TEXT]:
                localctx = DParser.ReplaceActionTextDActionContext(self, localctx)
                self.enterOuterAlt(localctx, 20)
                self.state = 370
                self.match(DParser.REPLACE_ACTION_TEXT)
                self.state = 371
                localctx._fileRule = self.fileRule()
                localctx.dlgs.append(localctx._fileRule)
                self.state = 372
                localctx.oldText = self.stringRule()
                self.state = 373
                localctx.newText = self.stringRule()
                self.state = 377
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while ((((_la - 60)) & ~0x3f) == 0 and ((1 << (_la - 60)) & ((1 << (DParser.IDENTIFIER - 60)) | (1 << (DParser.TILDE_STRING - 60)) | (1 << (DParser.QUOTE_STRING - 60)) | (1 << (DParser.PERCENT_STRING - 60)) | (1 << (DParser.LONG_TILDE_STRING - 60)))) != 0):
                    self.state = 374
                    localctx._fileRule = self.fileRule()
                    localctx.dlgs.append(localctx._fileRule)
                    self.state = 379
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 383
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==DParser.IF or _la==DParser.UNLESS:
                    self.state = 380
                    localctx._conditionRule = self.conditionRule()
                    localctx.conditions.append(localctx._conditionRule)
                    self.state = 385
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                pass
            elif token in [DParser.REPLACE_ACTION_TEXT_REGEXP]:
                localctx = DParser.ReplaceActionTextRegexpDActionContext(self, localctx)
                self.enterOuterAlt(localctx, 21)
                self.state = 386
                self.match(DParser.REPLACE_ACTION_TEXT_REGEXP)
                self.state = 387
                localctx._stringRule = self.stringRule()
                localctx.dlgRegexps.append(localctx._stringRule)
                self.state = 388
                localctx.oldText = self.stringRule()
                self.state = 389
                localctx.newText = self.stringRule()
                self.state = 393
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while ((((_la - 60)) & ~0x3f) == 0 and ((1 << (_la - 60)) & ((1 << (DParser.IDENTIFIER - 60)) | (1 << (DParser.TILDE_STRING - 60)) | (1 << (DParser.QUOTE_STRING - 60)) | (1 << (DParser.PERCENT_STRING - 60)) | (1 << (DParser.LONG_TILDE_STRING - 60)))) != 0):
                    self.state = 390
                    localctx._stringRule = self.stringRule()
                    localctx.dlgRegexps.append(localctx._stringRule)
                    self.state = 395
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 399
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==DParser.IF or _la==DParser.UNLESS:
                    self.state = 396
                    localctx._conditionRule = self.conditionRule()
                    localctx.conditions.append(localctx._conditionRule)
                    self.state = 401
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                pass
            elif token in [DParser.REPLACE_ACTION_TEXT_PROCESS]:
                localctx = DParser.ReplaceActionTextProcessDActionContext(self, localctx)
                self.enterOuterAlt(localctx, 22)
                self.state = 402
                self.match(DParser.REPLACE_ACTION_TEXT_PROCESS)
                self.state = 403
                localctx._fileRule = self.fileRule()
                localctx.dlgs.append(localctx._fileRule)
                self.state = 404
                localctx.oldText = self.stringRule()
                self.state = 405
                localctx.newText = self.stringRule()
                self.state = 409
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while ((((_la - 60)) & ~0x3f) == 0 and ((1 << (_la - 60)) & ((1 << (DParser.IDENTIFIER - 60)) | (1 << (DParser.TILDE_STRING - 60)) | (1 << (DParser.QUOTE_STRING - 60)) | (1 << (DParser.PERCENT_STRING - 60)) | (1 << (DParser.LONG_TILDE_STRING - 60)))) != 0):
                    self.state = 406
                    localctx._fileRule = self.fileRule()
                    localctx.dlgs.append(localctx._fileRule)
                    self.state = 411
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 415
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==DParser.IF or _la==DParser.UNLESS:
                    self.state = 412
                    localctx._conditionRule = self.conditionRule()
                    localctx.conditions.append(localctx._conditionRule)
                    self.state = 417
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                pass
            elif token in [DParser.REPLACE_ACTION_TEXT_PROCESS_REGEXP]:
                localctx = DParser.ReplaceActionTextProcessRegexpDActionContext(self, localctx)
                self.enterOuterAlt(localctx, 23)
                self.state = 418
                self.match(DParser.REPLACE_ACTION_TEXT_PROCESS_REGEXP)
                self.state = 419
                localctx._stringRule = self.stringRule()
                localctx.dlgRegexps.append(localctx._stringRule)
                self.state = 420
                localctx.oldText = self.stringRule()
                self.state = 421
                localctx.newText = self.stringRule()
                self.state = 425
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while ((((_la - 60)) & ~0x3f) == 0 and ((1 << (_la - 60)) & ((1 << (DParser.IDENTIFIER - 60)) | (1 << (DParser.TILDE_STRING - 60)) | (1 << (DParser.QUOTE_STRING - 60)) | (1 << (DParser.PERCENT_STRING - 60)) | (1 << (DParser.LONG_TILDE_STRING - 60)))) != 0):
                    self.state = 422
                    localctx._stringRule = self.stringRule()
                    localctx.dlgRegexps.append(localctx._stringRule)
                    self.state = 427
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 431
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==DParser.IF or _la==DParser.UNLESS:
                    self.state = 428
                    localctx._conditionRule = self.conditionRule()
                    localctx.conditions.append(localctx._conditionRule)
                    self.state = 433
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AlterTransCommandContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.commandType = None # StringRuleContext
            self.newVal = None # StringRuleContext

        def stringRule(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(DParser.StringRuleContext)
            else:
                return self.getTypedRuleContext(DParser.StringRuleContext,i)


        def getRuleIndex(self):
            return DParser.RULE_alterTransCommand

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAlterTransCommand" ):
                listener.enterAlterTransCommand(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAlterTransCommand" ):
                listener.exitAlterTransCommand(self)




    def alterTransCommand(self):

        localctx = DParser.AlterTransCommandContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_alterTransCommand)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 436
            localctx.commandType = self.stringRule()
            self.state = 437
            localctx.newVal = self.stringRule()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ConditionRuleContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.isIf = None # Token
            self.isUnless = None # Token
            self.predicate = None # StringRuleContext

        def stringRule(self):
            return self.getTypedRuleContext(DParser.StringRuleContext,0)


        def IF(self):
            return self.getToken(DParser.IF, 0)

        def UNLESS(self):
            return self.getToken(DParser.UNLESS, 0)

        def getRuleIndex(self):
            return DParser.RULE_conditionRule

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConditionRule" ):
                listener.enterConditionRule(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConditionRule" ):
                listener.exitConditionRule(self)




    def conditionRule(self):

        localctx = DParser.ConditionRuleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_conditionRule)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 441
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [DParser.IF]:
                self.state = 439
                localctx.isIf = self.match(DParser.IF)
                pass
            elif token in [DParser.UNLESS]:
                self.state = 440
                localctx.isUnless = self.match(DParser.UNLESS)
                pass
            else:
                raise NoViableAltException(self)

            self.state = 443
            localctx.predicate = self.stringRule()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StateRuleContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return DParser.RULE_stateRule

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class IfThenStateContext(StateRuleContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a DParser.StateRuleContext
            super().__init__(parser)
            self.weight = None # SharpNumberRuleContext
            self.trigger = None # StringRuleContext
            self.label = None # StringRuleContext
            self._sayTextRule = None # SayTextRuleContext
            self.lines = list() # of SayTextRuleContexts
            self._transitionRule = None # TransitionRuleContext
            self.transitions = list() # of TransitionRuleContexts
            self.copyFrom(ctx)

        def IF(self):
            return self.getToken(DParser.IF, 0)
        def SAY(self):
            return self.getToken(DParser.SAY, 0)
        def END(self):
            return self.getToken(DParser.END, 0)
        def stringRule(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(DParser.StringRuleContext)
            else:
                return self.getTypedRuleContext(DParser.StringRuleContext,i)

        def sayTextRule(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(DParser.SayTextRuleContext)
            else:
                return self.getTypedRuleContext(DParser.SayTextRuleContext,i)

        def WEIGHT(self):
            return self.getToken(DParser.WEIGHT, 0)
        def THEN(self):
            return self.getToken(DParser.THEN, 0)
        def BEGIN(self):
            return self.getToken(DParser.BEGIN, 0)
        def EQ(self, i:int=None):
            if i is None:
                return self.getTokens(DParser.EQ)
            else:
                return self.getToken(DParser.EQ, i)
        def sharpNumberRule(self):
            return self.getTypedRuleContext(DParser.SharpNumberRuleContext,0)

        def transitionRule(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(DParser.TransitionRuleContext)
            else:
                return self.getTypedRuleContext(DParser.TransitionRuleContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIfThenState" ):
                listener.enterIfThenState(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIfThenState" ):
                listener.exitIfThenState(self)


    class AppendiStateContext(StateRuleContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a DParser.StateRuleContext
            super().__init__(parser)
            self.dlg = None # FileRuleContext
            self._stateRule = None # StateRuleContext
            self.states = list() # of StateRuleContexts
            self.copyFrom(ctx)

        def APPENDI(self):
            return self.getToken(DParser.APPENDI, 0)
        def END(self):
            return self.getToken(DParser.END, 0)
        def fileRule(self):
            return self.getTypedRuleContext(DParser.FileRuleContext,0)

        def stateRule(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(DParser.StateRuleContext)
            else:
                return self.getTypedRuleContext(DParser.StateRuleContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAppendiState" ):
                listener.enterAppendiState(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAppendiState" ):
                listener.exitAppendiState(self)


    class Chain2StateContext(StateRuleContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a DParser.StateRuleContext
            super().__init__(parser)
            self.dlg = None # FileRuleContext
            self.entryLabel = None # StringRuleContext
            self.body = None # Chain2DlgRuleContext
            self.exitDlg = None # FileRuleContext
            self.exitLabel = None # StringRuleContext
            self.copyFrom(ctx)

        def CHAIN2(self):
            return self.getToken(DParser.CHAIN2, 0)
        def END(self):
            return self.getToken(DParser.END, 0)
        def fileRule(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(DParser.FileRuleContext)
            else:
                return self.getTypedRuleContext(DParser.FileRuleContext,i)

        def stringRule(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(DParser.StringRuleContext)
            else:
                return self.getTypedRuleContext(DParser.StringRuleContext,i)

        def chain2DlgRule(self):
            return self.getTypedRuleContext(DParser.Chain2DlgRuleContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterChain2State" ):
                listener.enterChain2State(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitChain2State" ):
                listener.exitChain2State(self)



    def stateRule(self):

        localctx = DParser.StateRuleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_stateRule)
        self._la = 0 # Token type
        try:
            self.state = 493
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [DParser.IF]:
                localctx = DParser.IfThenStateContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 445
                self.match(DParser.IF)
                self.state = 448
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==DParser.WEIGHT:
                    self.state = 446
                    self.match(DParser.WEIGHT)
                    self.state = 447
                    localctx.weight = self.sharpNumberRule()


                self.state = 450
                localctx.trigger = self.stringRule()
                self.state = 452
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==DParser.THEN:
                    self.state = 451
                    self.match(DParser.THEN)


                self.state = 455
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==DParser.BEGIN:
                    self.state = 454
                    self.match(DParser.BEGIN)


                self.state = 457
                localctx.label = self.stringRule()
                self.state = 458
                self.match(DParser.SAY)
                self.state = 459
                localctx._sayTextRule = self.sayTextRule()
                localctx.lines.append(localctx._sayTextRule)
                self.state = 464
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==DParser.EQ:
                    self.state = 460
                    self.match(DParser.EQ)
                    self.state = 461
                    localctx._sayTextRule = self.sayTextRule()
                    localctx.lines.append(localctx._sayTextRule)
                    self.state = 466
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 470
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << DParser.IF) | (1 << DParser.PLUS) | (1 << DParser.COPY_TRANS) | (1 << DParser.COPY_TRANS_LATE))) != 0):
                    self.state = 467
                    localctx._transitionRule = self.transitionRule()
                    localctx.transitions.append(localctx._transitionRule)
                    self.state = 472
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 473
                self.match(DParser.END)
                pass
            elif token in [DParser.APPENDI]:
                localctx = DParser.AppendiStateContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 475
                self.match(DParser.APPENDI)
                self.state = 476
                localctx.dlg = self.fileRule()
                self.state = 480
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << DParser.IF) | (1 << DParser.APPENDI) | (1 << DParser.CHAIN2))) != 0):
                    self.state = 477
                    localctx._stateRule = self.stateRule()
                    localctx.states.append(localctx._stateRule)
                    self.state = 482
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 483
                self.match(DParser.END)
                pass
            elif token in [DParser.CHAIN2]:
                localctx = DParser.Chain2StateContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 485
                self.match(DParser.CHAIN2)
                self.state = 486
                localctx.dlg = self.fileRule()
                self.state = 487
                localctx.entryLabel = self.stringRule()
                self.state = 488
                localctx.body = self.chain2DlgRule()
                self.state = 489
                self.match(DParser.END)
                self.state = 490
                localctx.exitDlg = self.fileRule()
                self.state = 491
                localctx.exitLabel = self.stringRule()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Chain2DlgRuleContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.initialLine = None # ChainElementRuleContext
            self._chain2ElementRule = None # Chain2ElementRuleContext
            self.restLines = list() # of Chain2ElementRuleContexts

        def chainElementRule(self):
            return self.getTypedRuleContext(DParser.ChainElementRuleContext,0)


        def chain2ElementRule(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(DParser.Chain2ElementRuleContext)
            else:
                return self.getTypedRuleContext(DParser.Chain2ElementRuleContext,i)


        def getRuleIndex(self):
            return DParser.RULE_chain2DlgRule

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterChain2DlgRule" ):
                listener.enterChain2DlgRule(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitChain2DlgRule" ):
                listener.exitChain2DlgRule(self)




    def chain2DlgRule(self):

        localctx = DParser.Chain2DlgRuleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_chain2DlgRule)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 495
            localctx.initialLine = self.chainElementRule()
            self.state = 499
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==DParser.EQ or _la==DParser.EQEQ:
                self.state = 496
                localctx._chain2ElementRule = self.chain2ElementRule()
                localctx.restLines.append(localctx._chain2ElementRule)
                self.state = 501
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Chain2ElementRuleContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.operator = None # Token
            self.line = None # ChainElementRuleContext

        def chainElementRule(self):
            return self.getTypedRuleContext(DParser.ChainElementRuleContext,0)


        def EQEQ(self):
            return self.getToken(DParser.EQEQ, 0)

        def EQ(self):
            return self.getToken(DParser.EQ, 0)

        def getRuleIndex(self):
            return DParser.RULE_chain2ElementRule

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterChain2ElementRule" ):
                listener.enterChain2ElementRule(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitChain2ElementRule" ):
                listener.exitChain2ElementRule(self)




    def chain2ElementRule(self):

        localctx = DParser.Chain2ElementRuleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_chain2ElementRule)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 504
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [DParser.EQEQ]:
                self.state = 502
                localctx.operator = self.match(DParser.EQEQ)
                pass
            elif token in [DParser.EQ]:
                self.state = 503
                localctx.operator = self.match(DParser.EQ)
                pass
            else:
                raise NoViableAltException(self)

            self.state = 506
            localctx.line = self.chainElementRule()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TransitionRuleContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return DParser.RULE_transitionRule

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class IfThenTransitionContext(TransitionRuleContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a DParser.TransitionRuleContext
            super().__init__(parser)
            self.trigger = None # StringRuleContext
            self._transitionFeatureRule = None # TransitionFeatureRuleContext
            self.features = list() # of TransitionFeatureRuleContexts
            self._transitionTargetRule = None # TransitionTargetRuleContext
            self.out = list() # of TransitionTargetRuleContexts
            self.copyFrom(ctx)

        def IF(self):
            return self.getToken(DParser.IF, 0)
        def stringRule(self):
            return self.getTypedRuleContext(DParser.StringRuleContext,0)

        def transitionTargetRule(self):
            return self.getTypedRuleContext(DParser.TransitionTargetRuleContext,0)

        def THEN(self):
            return self.getToken(DParser.THEN, 0)
        def transitionFeatureRule(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(DParser.TransitionFeatureRuleContext)
            else:
                return self.getTypedRuleContext(DParser.TransitionFeatureRuleContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIfThenTransition" ):
                listener.enterIfThenTransition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIfThenTransition" ):
                listener.exitIfThenTransition(self)


    class CopyTransTransitionContext(TransitionRuleContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a DParser.TransitionRuleContext
            super().__init__(parser)
            self.safe = None # Token
            self.dlg = None # FileRuleContext
            self.label = None # StringRuleContext
            self.copyFrom(ctx)

        def COPY_TRANS(self):
            return self.getToken(DParser.COPY_TRANS, 0)
        def fileRule(self):
            return self.getTypedRuleContext(DParser.FileRuleContext,0)

        def stringRule(self):
            return self.getTypedRuleContext(DParser.StringRuleContext,0)

        def SAFE(self):
            return self.getToken(DParser.SAFE, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCopyTransTransition" ):
                listener.enterCopyTransTransition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCopyTransTransition" ):
                listener.exitCopyTransTransition(self)


    class ReplyTransitionContext(TransitionRuleContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a DParser.TransitionRuleContext
            super().__init__(parser)
            self.trigger = None # StringRuleContext
            self.reply = None # SayTextRuleContext
            self._transitionFeatureRule = None # TransitionFeatureRuleContext
            self.features = list() # of TransitionFeatureRuleContexts
            self._transitionTargetRule = None # TransitionTargetRuleContext
            self.out = list() # of TransitionTargetRuleContexts
            self.copyFrom(ctx)

        def PLUS(self, i:int=None):
            if i is None:
                return self.getTokens(DParser.PLUS)
            else:
                return self.getToken(DParser.PLUS, i)
        def sayTextRule(self):
            return self.getTypedRuleContext(DParser.SayTextRuleContext,0)

        def transitionTargetRule(self):
            return self.getTypedRuleContext(DParser.TransitionTargetRuleContext,0)

        def stringRule(self):
            return self.getTypedRuleContext(DParser.StringRuleContext,0)

        def transitionFeatureRule(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(DParser.TransitionFeatureRuleContext)
            else:
                return self.getTypedRuleContext(DParser.TransitionFeatureRuleContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterReplyTransition" ):
                listener.enterReplyTransition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitReplyTransition" ):
                listener.exitReplyTransition(self)


    class CopyTransLateTransitionContext(TransitionRuleContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a DParser.TransitionRuleContext
            super().__init__(parser)
            self.safe = None # Token
            self.dlg = None # FileRuleContext
            self.label = None # StringRuleContext
            self.copyFrom(ctx)

        def COPY_TRANS_LATE(self):
            return self.getToken(DParser.COPY_TRANS_LATE, 0)
        def fileRule(self):
            return self.getTypedRuleContext(DParser.FileRuleContext,0)

        def stringRule(self):
            return self.getTypedRuleContext(DParser.StringRuleContext,0)

        def SAFE(self):
            return self.getToken(DParser.SAFE, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCopyTransLateTransition" ):
                listener.enterCopyTransLateTransition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCopyTransLateTransition" ):
                listener.exitCopyTransLateTransition(self)



    def transitionRule(self):

        localctx = DParser.TransitionRuleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_transitionRule)
        self._la = 0 # Token type
        try:
            self.state = 549
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [DParser.IF]:
                localctx = DParser.IfThenTransitionContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 508
                self.match(DParser.IF)
                self.state = 509
                localctx.trigger = self.stringRule()
                self.state = 511
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==DParser.THEN:
                    self.state = 510
                    self.match(DParser.THEN)


                self.state = 516
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << DParser.DO) | (1 << DParser.JOURNAL) | (1 << DParser.SOLVED_JOURNAL) | (1 << DParser.UNSOLVED_JOURNAL) | (1 << DParser.FLAGS) | (1 << DParser.REPLY))) != 0):
                    self.state = 513
                    localctx._transitionFeatureRule = self.transitionFeatureRule()
                    localctx.features.append(localctx._transitionFeatureRule)
                    self.state = 518
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 519
                localctx._transitionTargetRule = self.transitionTargetRule()
                localctx.out.append(localctx._transitionTargetRule)
                pass
            elif token in [DParser.PLUS]:
                localctx = DParser.ReplyTransitionContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 521
                self.match(DParser.PLUS)
                self.state = 523
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if ((((_la - 60)) & ~0x3f) == 0 and ((1 << (_la - 60)) & ((1 << (DParser.IDENTIFIER - 60)) | (1 << (DParser.TILDE_STRING - 60)) | (1 << (DParser.QUOTE_STRING - 60)) | (1 << (DParser.PERCENT_STRING - 60)) | (1 << (DParser.LONG_TILDE_STRING - 60)))) != 0):
                    self.state = 522
                    localctx.trigger = self.stringRule()


                self.state = 525
                self.match(DParser.PLUS)
                self.state = 526
                localctx.reply = self.sayTextRule()
                self.state = 530
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << DParser.DO) | (1 << DParser.JOURNAL) | (1 << DParser.SOLVED_JOURNAL) | (1 << DParser.UNSOLVED_JOURNAL) | (1 << DParser.FLAGS) | (1 << DParser.REPLY))) != 0):
                    self.state = 527
                    localctx._transitionFeatureRule = self.transitionFeatureRule()
                    localctx.features.append(localctx._transitionFeatureRule)
                    self.state = 532
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 533
                localctx._transitionTargetRule = self.transitionTargetRule()
                localctx.out.append(localctx._transitionTargetRule)
                pass
            elif token in [DParser.COPY_TRANS]:
                localctx = DParser.CopyTransTransitionContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 535
                self.match(DParser.COPY_TRANS)
                self.state = 537
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==DParser.SAFE:
                    self.state = 536
                    localctx.safe = self.match(DParser.SAFE)


                self.state = 539
                localctx.dlg = self.fileRule()
                self.state = 540
                localctx.label = self.stringRule()
                pass
            elif token in [DParser.COPY_TRANS_LATE]:
                localctx = DParser.CopyTransLateTransitionContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 542
                self.match(DParser.COPY_TRANS_LATE)
                self.state = 544
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==DParser.SAFE:
                    self.state = 543
                    localctx.safe = self.match(DParser.SAFE)


                self.state = 546
                localctx.dlg = self.fileRule()
                self.state = 547
                localctx.label = self.stringRule()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TransitionTargetRuleContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return DParser.RULE_transitionTargetRule

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class ExternTransitionTargetContext(TransitionTargetRuleContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a DParser.TransitionTargetRuleContext
            super().__init__(parser)
            self.ifExists = None # Token
            self.dlg = None # FileRuleContext
            self.label = None # StringRuleContext
            self.copyFrom(ctx)

        def EXTERN(self):
            return self.getToken(DParser.EXTERN, 0)
        def fileRule(self):
            return self.getTypedRuleContext(DParser.FileRuleContext,0)

        def stringRule(self):
            return self.getTypedRuleContext(DParser.StringRuleContext,0)

        def IF_FILE_EXISTS(self):
            return self.getToken(DParser.IF_FILE_EXISTS, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExternTransitionTarget" ):
                listener.enterExternTransitionTarget(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExternTransitionTarget" ):
                listener.exitExternTransitionTarget(self)


    class ExitTransitionTargetContext(TransitionTargetRuleContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a DParser.TransitionTargetRuleContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def EXIT(self):
            return self.getToken(DParser.EXIT, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExitTransitionTarget" ):
                listener.enterExitTransitionTarget(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExitTransitionTarget" ):
                listener.exitExitTransitionTarget(self)


    class GotoTransitionTargetContext(TransitionTargetRuleContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a DParser.TransitionTargetRuleContext
            super().__init__(parser)
            self.label = None # StringRuleContext
            self.copyFrom(ctx)

        def GOTO(self):
            return self.getToken(DParser.GOTO, 0)
        def PLUS(self):
            return self.getToken(DParser.PLUS, 0)
        def stringRule(self):
            return self.getTypedRuleContext(DParser.StringRuleContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGotoTransitionTarget" ):
                listener.enterGotoTransitionTarget(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGotoTransitionTarget" ):
                listener.exitGotoTransitionTarget(self)



    def transitionTargetRule(self):

        localctx = DParser.TransitionTargetRuleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_transitionTargetRule)
        self._la = 0 # Token type
        try:
            self.state = 561
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [DParser.PLUS, DParser.GOTO]:
                localctx = DParser.GotoTransitionTargetContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 551
                _la = self._input.LA(1)
                if not(_la==DParser.PLUS or _la==DParser.GOTO):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 552
                localctx.label = self.stringRule()
                pass
            elif token in [DParser.EXTERN]:
                localctx = DParser.ExternTransitionTargetContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 553
                self.match(DParser.EXTERN)
                self.state = 555
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==DParser.IF_FILE_EXISTS:
                    self.state = 554
                    localctx.ifExists = self.match(DParser.IF_FILE_EXISTS)


                self.state = 557
                localctx.dlg = self.fileRule()
                self.state = 558
                localctx.label = self.stringRule()
                pass
            elif token in [DParser.EXIT]:
                localctx = DParser.ExitTransitionTargetContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 560
                self.match(DParser.EXIT)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ChainActionEpilogRuleContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return DParser.RULE_chainActionEpilogRule

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class ExitChainActionEpilogContext(ChainActionEpilogRuleContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a DParser.ChainActionEpilogRuleContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def EXIT(self):
            return self.getToken(DParser.EXIT, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExitChainActionEpilog" ):
                listener.enterExitChainActionEpilog(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExitChainActionEpilog" ):
                listener.exitExitChainActionEpilog(self)


    class CopyTransLateChainActionEpilogContext(ChainActionEpilogRuleContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a DParser.ChainActionEpilogRuleContext
            super().__init__(parser)
            self.safe = None # Token
            self.dlg = None # FileRuleContext
            self.label = None # StringRuleContext
            self.copyFrom(ctx)

        def COPY_TRANS_LATE(self):
            return self.getToken(DParser.COPY_TRANS_LATE, 0)
        def fileRule(self):
            return self.getTypedRuleContext(DParser.FileRuleContext,0)

        def stringRule(self):
            return self.getTypedRuleContext(DParser.StringRuleContext,0)

        def SAFE(self):
            return self.getToken(DParser.SAFE, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCopyTransLateChainActionEpilog" ):
                listener.enterCopyTransLateChainActionEpilog(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCopyTransLateChainActionEpilog" ):
                listener.exitCopyTransLateChainActionEpilog(self)


    class CopyTransChainActionEpilogContext(ChainActionEpilogRuleContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a DParser.ChainActionEpilogRuleContext
            super().__init__(parser)
            self.safe = None # Token
            self.dlg = None # FileRuleContext
            self.label = None # StringRuleContext
            self.copyFrom(ctx)

        def COPY_TRANS(self):
            return self.getToken(DParser.COPY_TRANS, 0)
        def fileRule(self):
            return self.getTypedRuleContext(DParser.FileRuleContext,0)

        def stringRule(self):
            return self.getTypedRuleContext(DParser.StringRuleContext,0)

        def SAFE(self):
            return self.getToken(DParser.SAFE, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCopyTransChainActionEpilog" ):
                listener.enterCopyTransChainActionEpilog(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCopyTransChainActionEpilog" ):
                listener.exitCopyTransChainActionEpilog(self)


    class EndWithTransitionsChainActionEpilogContext(ChainActionEpilogRuleContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a DParser.ChainActionEpilogRuleContext
            super().__init__(parser)
            self._transitionRule = None # TransitionRuleContext
            self.transitions = list() # of TransitionRuleContexts
            self.copyFrom(ctx)

        def END(self):
            return self.getToken(DParser.END, 0)
        def transitionRule(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(DParser.TransitionRuleContext)
            else:
                return self.getTypedRuleContext(DParser.TransitionRuleContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEndWithTransitionsChainActionEpilog" ):
                listener.enterEndWithTransitionsChainActionEpilog(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEndWithTransitionsChainActionEpilog" ):
                listener.exitEndWithTransitionsChainActionEpilog(self)


    class EndChainActionEpilogContext(ChainActionEpilogRuleContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a DParser.ChainActionEpilogRuleContext
            super().__init__(parser)
            self.dlg = None # FileRuleContext
            self.label = None # StringRuleContext
            self.copyFrom(ctx)

        def END(self):
            return self.getToken(DParser.END, 0)
        def fileRule(self):
            return self.getTypedRuleContext(DParser.FileRuleContext,0)

        def stringRule(self):
            return self.getTypedRuleContext(DParser.StringRuleContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEndChainActionEpilog" ):
                listener.enterEndChainActionEpilog(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEndChainActionEpilog" ):
                listener.exitEndChainActionEpilog(self)


    class ExternChainActionEpilogContext(ChainActionEpilogRuleContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a DParser.ChainActionEpilogRuleContext
            super().__init__(parser)
            self.dlg = None # FileRuleContext
            self.label = None # StringRuleContext
            self.copyFrom(ctx)

        def EXTERN(self):
            return self.getToken(DParser.EXTERN, 0)
        def fileRule(self):
            return self.getTypedRuleContext(DParser.FileRuleContext,0)

        def stringRule(self):
            return self.getTypedRuleContext(DParser.StringRuleContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExternChainActionEpilog" ):
                listener.enterExternChainActionEpilog(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExternChainActionEpilog" ):
                listener.exitExternChainActionEpilog(self)



    def chainActionEpilogRule(self):

        localctx = DParser.ChainActionEpilogRuleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_chainActionEpilogRule)
        self._la = 0 # Token type
        try:
            self.state = 593
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,73,self._ctx)
            if la_ == 1:
                localctx = DParser.EndChainActionEpilogContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 563
                self.match(DParser.END)
                self.state = 564
                localctx.dlg = self.fileRule()
                self.state = 565
                localctx.label = self.stringRule()
                pass

            elif la_ == 2:
                localctx = DParser.ExternChainActionEpilogContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 567
                self.match(DParser.EXTERN)
                self.state = 568
                localctx.dlg = self.fileRule()
                self.state = 569
                localctx.label = self.stringRule()
                pass

            elif la_ == 3:
                localctx = DParser.CopyTransChainActionEpilogContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 571
                self.match(DParser.COPY_TRANS)
                self.state = 573
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==DParser.SAFE:
                    self.state = 572
                    localctx.safe = self.match(DParser.SAFE)


                self.state = 575
                localctx.dlg = self.fileRule()
                self.state = 576
                localctx.label = self.stringRule()
                pass

            elif la_ == 4:
                localctx = DParser.CopyTransLateChainActionEpilogContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 578
                self.match(DParser.COPY_TRANS_LATE)
                self.state = 580
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==DParser.SAFE:
                    self.state = 579
                    localctx.safe = self.match(DParser.SAFE)


                self.state = 582
                localctx.dlg = self.fileRule()
                self.state = 583
                localctx.label = self.stringRule()
                pass

            elif la_ == 5:
                localctx = DParser.ExitChainActionEpilogContext(self, localctx)
                self.enterOuterAlt(localctx, 5)
                self.state = 585
                self.match(DParser.EXIT)
                pass

            elif la_ == 6:
                localctx = DParser.EndWithTransitionsChainActionEpilogContext(self, localctx)
                self.enterOuterAlt(localctx, 6)
                self.state = 586
                self.match(DParser.END)
                self.state = 590
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << DParser.IF) | (1 << DParser.PLUS) | (1 << DParser.COPY_TRANS) | (1 << DParser.COPY_TRANS_LATE))) != 0):
                    self.state = 587
                    localctx._transitionRule = self.transitionRule()
                    localctx.transitions.append(localctx._transitionRule)
                    self.state = 592
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TransitionFeatureRuleContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return DParser.RULE_transitionFeatureRule

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class UnsolvedJournalTransitionFeatureContext(TransitionFeatureRuleContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a DParser.TransitionFeatureRuleContext
            super().__init__(parser)
            self.entry = None # DlgLineRuleContext
            self.copyFrom(ctx)

        def UNSOLVED_JOURNAL(self):
            return self.getToken(DParser.UNSOLVED_JOURNAL, 0)
        def dlgLineRule(self):
            return self.getTypedRuleContext(DParser.DlgLineRuleContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnsolvedJournalTransitionFeature" ):
                listener.enterUnsolvedJournalTransitionFeature(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnsolvedJournalTransitionFeature" ):
                listener.exitUnsolvedJournalTransitionFeature(self)


    class FlagsTransitionFeatureContext(TransitionFeatureRuleContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a DParser.TransitionFeatureRuleContext
            super().__init__(parser)
            self.flags = None # StringRuleContext
            self.copyFrom(ctx)

        def FLAGS(self):
            return self.getToken(DParser.FLAGS, 0)
        def stringRule(self):
            return self.getTypedRuleContext(DParser.StringRuleContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFlagsTransitionFeature" ):
                listener.enterFlagsTransitionFeature(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFlagsTransitionFeature" ):
                listener.exitFlagsTransitionFeature(self)


    class JournalTransitionFeatureContext(TransitionFeatureRuleContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a DParser.TransitionFeatureRuleContext
            super().__init__(parser)
            self.entry = None # DlgLineRuleContext
            self.copyFrom(ctx)

        def JOURNAL(self):
            return self.getToken(DParser.JOURNAL, 0)
        def dlgLineRule(self):
            return self.getTypedRuleContext(DParser.DlgLineRuleContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterJournalTransitionFeature" ):
                listener.enterJournalTransitionFeature(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitJournalTransitionFeature" ):
                listener.exitJournalTransitionFeature(self)


    class DoTransitionFeatureContext(TransitionFeatureRuleContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a DParser.TransitionFeatureRuleContext
            super().__init__(parser)
            self.action = None # StringRuleContext
            self.copyFrom(ctx)

        def DO(self):
            return self.getToken(DParser.DO, 0)
        def stringRule(self):
            return self.getTypedRuleContext(DParser.StringRuleContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDoTransitionFeature" ):
                listener.enterDoTransitionFeature(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDoTransitionFeature" ):
                listener.exitDoTransitionFeature(self)


    class SolvedJournalTransitionFeatureContext(TransitionFeatureRuleContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a DParser.TransitionFeatureRuleContext
            super().__init__(parser)
            self.entry = None # DlgLineRuleContext
            self.copyFrom(ctx)

        def SOLVED_JOURNAL(self):
            return self.getToken(DParser.SOLVED_JOURNAL, 0)
        def dlgLineRule(self):
            return self.getTypedRuleContext(DParser.DlgLineRuleContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSolvedJournalTransitionFeature" ):
                listener.enterSolvedJournalTransitionFeature(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSolvedJournalTransitionFeature" ):
                listener.exitSolvedJournalTransitionFeature(self)


    class ReplyTransitionFeatureContext(TransitionFeatureRuleContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a DParser.TransitionFeatureRuleContext
            super().__init__(parser)
            self.line = None # DlgLineRuleContext
            self.copyFrom(ctx)

        def REPLY(self):
            return self.getToken(DParser.REPLY, 0)
        def dlgLineRule(self):
            return self.getTypedRuleContext(DParser.DlgLineRuleContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterReplyTransitionFeature" ):
                listener.enterReplyTransitionFeature(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitReplyTransitionFeature" ):
                listener.exitReplyTransitionFeature(self)



    def transitionFeatureRule(self):

        localctx = DParser.TransitionFeatureRuleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_transitionFeatureRule)
        try:
            self.state = 607
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [DParser.REPLY]:
                localctx = DParser.ReplyTransitionFeatureContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 595
                self.match(DParser.REPLY)
                self.state = 596
                localctx.line = self.dlgLineRule()
                pass
            elif token in [DParser.DO]:
                localctx = DParser.DoTransitionFeatureContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 597
                self.match(DParser.DO)
                self.state = 598
                localctx.action = self.stringRule()
                pass
            elif token in [DParser.JOURNAL]:
                localctx = DParser.JournalTransitionFeatureContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 599
                self.match(DParser.JOURNAL)
                self.state = 600
                localctx.entry = self.dlgLineRule()
                pass
            elif token in [DParser.SOLVED_JOURNAL]:
                localctx = DParser.SolvedJournalTransitionFeatureContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 601
                self.match(DParser.SOLVED_JOURNAL)
                self.state = 602
                localctx.entry = self.dlgLineRule()
                pass
            elif token in [DParser.UNSOLVED_JOURNAL]:
                localctx = DParser.UnsolvedJournalTransitionFeatureContext(self, localctx)
                self.enterOuterAlt(localctx, 5)
                self.state = 603
                self.match(DParser.UNSOLVED_JOURNAL)
                self.state = 604
                localctx.entry = self.dlgLineRule()
                pass
            elif token in [DParser.FLAGS]:
                localctx = DParser.FlagsTransitionFeatureContext(self, localctx)
                self.enterOuterAlt(localctx, 6)
                self.state = 605
                self.match(DParser.FLAGS)
                self.state = 606
                localctx.flags = self.stringRule()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ChainDlgRuleContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.trigger = None # StringRuleContext
            self._chainElementRule = None # ChainElementRuleContext
            self.initialSpeakerLines = list() # of ChainElementRuleContexts
            self._chainBlockRule = None # ChainBlockRuleContext
            self.blocks = list() # of ChainBlockRuleContexts

        def chainElementRule(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(DParser.ChainElementRuleContext)
            else:
                return self.getTypedRuleContext(DParser.ChainElementRuleContext,i)


        def IF(self):
            return self.getToken(DParser.IF, 0)

        def THEN(self):
            return self.getToken(DParser.THEN, 0)

        def EQ(self, i:int=None):
            if i is None:
                return self.getTokens(DParser.EQ)
            else:
                return self.getToken(DParser.EQ, i)

        def stringRule(self):
            return self.getTypedRuleContext(DParser.StringRuleContext,0)


        def chainBlockRule(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(DParser.ChainBlockRuleContext)
            else:
                return self.getTypedRuleContext(DParser.ChainBlockRuleContext,i)


        def getRuleIndex(self):
            return DParser.RULE_chainDlgRule

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterChainDlgRule" ):
                listener.enterChainDlgRule(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitChainDlgRule" ):
                listener.exitChainDlgRule(self)




    def chainDlgRule(self):

        localctx = DParser.ChainDlgRuleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_chainDlgRule)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 613
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,75,self._ctx)
            if la_ == 1:
                self.state = 609
                self.match(DParser.IF)
                self.state = 610
                localctx.trigger = self.stringRule()
                self.state = 611
                self.match(DParser.THEN)


            self.state = 615
            localctx._chainElementRule = self.chainElementRule()
            localctx.initialSpeakerLines.append(localctx._chainElementRule)
            self.state = 620
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==DParser.EQ:
                self.state = 616
                self.match(DParser.EQ)
                self.state = 617
                localctx._chainElementRule = self.chainElementRule()
                localctx.initialSpeakerLines.append(localctx._chainElementRule)
                self.state = 622
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 626
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==DParser.EQEQ or _la==DParser.BRANCH:
                self.state = 623
                localctx._chainBlockRule = self.chainBlockRule()
                localctx.blocks.append(localctx._chainBlockRule)
                self.state = 628
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ChainBlockRuleContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return DParser.RULE_chainBlockRule

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class BranchChainBlockContext(ChainBlockRuleContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a DParser.ChainBlockRuleContext
            super().__init__(parser)
            self.trigger = None # StringRuleContext
            self._chainBlockRule = None # ChainBlockRuleContext
            self.blocks = list() # of ChainBlockRuleContexts
            self.copyFrom(ctx)

        def BRANCH(self):
            return self.getToken(DParser.BRANCH, 0)
        def BEGIN(self):
            return self.getToken(DParser.BEGIN, 0)
        def END(self):
            return self.getToken(DParser.END, 0)
        def stringRule(self):
            return self.getTypedRuleContext(DParser.StringRuleContext,0)

        def chainBlockRule(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(DParser.ChainBlockRuleContext)
            else:
                return self.getTypedRuleContext(DParser.ChainBlockRuleContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBranchChainBlock" ):
                listener.enterBranchChainBlock(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBranchChainBlock" ):
                listener.exitBranchChainBlock(self)


    class MonologChainBlockContext(ChainBlockRuleContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a DParser.ChainBlockRuleContext
            super().__init__(parser)
            self.ifExists = None # Token
            self.dlg = None # FileRuleContext
            self._chainElementRule = None # ChainElementRuleContext
            self.elements = list() # of ChainElementRuleContexts
            self.copyFrom(ctx)

        def EQEQ(self):
            return self.getToken(DParser.EQEQ, 0)
        def fileRule(self):
            return self.getTypedRuleContext(DParser.FileRuleContext,0)

        def chainElementRule(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(DParser.ChainElementRuleContext)
            else:
                return self.getTypedRuleContext(DParser.ChainElementRuleContext,i)

        def EQ(self, i:int=None):
            if i is None:
                return self.getTokens(DParser.EQ)
            else:
                return self.getToken(DParser.EQ, i)
        def IF_FILE_EXISTS(self):
            return self.getToken(DParser.IF_FILE_EXISTS, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMonologChainBlock" ):
                listener.enterMonologChainBlock(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMonologChainBlock" ):
                listener.exitMonologChainBlock(self)



    def chainBlockRule(self):

        localctx = DParser.ChainBlockRuleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_chainBlockRule)
        self._la = 0 # Token type
        try:
            self.state = 653
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [DParser.EQEQ]:
                localctx = DParser.MonologChainBlockContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 629
                self.match(DParser.EQEQ)
                self.state = 631
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==DParser.IF_FILE_EXISTS:
                    self.state = 630
                    localctx.ifExists = self.match(DParser.IF_FILE_EXISTS)


                self.state = 633
                localctx.dlg = self.fileRule()
                self.state = 634
                localctx._chainElementRule = self.chainElementRule()
                localctx.elements.append(localctx._chainElementRule)
                self.state = 639
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==DParser.EQ:
                    self.state = 635
                    self.match(DParser.EQ)
                    self.state = 636
                    localctx._chainElementRule = self.chainElementRule()
                    localctx.elements.append(localctx._chainElementRule)
                    self.state = 641
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                pass
            elif token in [DParser.BRANCH]:
                localctx = DParser.BranchChainBlockContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 642
                self.match(DParser.BRANCH)
                self.state = 643
                localctx.trigger = self.stringRule()
                self.state = 644
                self.match(DParser.BEGIN)
                self.state = 648
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==DParser.EQEQ or _la==DParser.BRANCH:
                    self.state = 645
                    localctx._chainBlockRule = self.chainBlockRule()
                    localctx.blocks.append(localctx._chainBlockRule)
                    self.state = 650
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 651
                self.match(DParser.END)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ChainElementRuleContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.trigger = None # StringRuleContext
            self.line = None # SayTextRuleContext
            self.action = None # StringRuleContext

        def sayTextRule(self):
            return self.getTypedRuleContext(DParser.SayTextRuleContext,0)


        def IF(self):
            return self.getToken(DParser.IF, 0)

        def DO(self):
            return self.getToken(DParser.DO, 0)

        def stringRule(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(DParser.StringRuleContext)
            else:
                return self.getTypedRuleContext(DParser.StringRuleContext,i)


        def THEN(self):
            return self.getToken(DParser.THEN, 0)

        def getRuleIndex(self):
            return DParser.RULE_chainElementRule

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterChainElementRule" ):
                listener.enterChainElementRule(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitChainElementRule" ):
                listener.exitChainElementRule(self)




    def chainElementRule(self):

        localctx = DParser.ChainElementRuleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_chainElementRule)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 660
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==DParser.IF:
                self.state = 655
                self.match(DParser.IF)
                self.state = 656
                localctx.trigger = self.stringRule()
                self.state = 658
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==DParser.THEN:
                    self.state = 657
                    self.match(DParser.THEN)




            self.state = 662
            localctx.line = self.sayTextRule()
            self.state = 665
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==DParser.DO:
                self.state = 663
                self.match(DParser.DO)
                self.state = 664
                localctx.action = self.stringRule()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FileRuleContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def stringRule(self):
            return self.getTypedRuleContext(DParser.StringRuleContext,0)


        def getRuleIndex(self):
            return DParser.RULE_fileRule

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFileRule" ):
                listener.enterFileRule(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFileRule" ):
                listener.exitFileRule(self)




    def fileRule(self):

        localctx = DParser.FileRuleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_fileRule)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 667
            self.stringRule()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SayTextRuleContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def dlgLineRule(self):
            return self.getTypedRuleContext(DParser.DlgLineRuleContext,0)


        def getRuleIndex(self):
            return DParser.RULE_sayTextRule

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSayTextRule" ):
                listener.enterSayTextRule(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSayTextRule" ):
                listener.exitSayTextRule(self)




    def sayTextRule(self):

        localctx = DParser.SayTextRuleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_sayTextRule)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 669
            self.dlgLineRule()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraLineRuleContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.string = None # StringRuleContext
            self.ref = None # ReferenceRuleContext
            self.dlgLine = None # DlgLineRuleContext

        def stringRule(self):
            return self.getTypedRuleContext(DParser.StringRuleContext,0)


        def referenceRule(self):
            return self.getTypedRuleContext(DParser.ReferenceRuleContext,0)


        def dlgLineRule(self):
            return self.getTypedRuleContext(DParser.DlgLineRuleContext,0)


        def getRuleIndex(self):
            return DParser.RULE_traLineRule

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraLineRule" ):
                listener.enterTraLineRule(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraLineRule" ):
                listener.exitTraLineRule(self)




    def traLineRule(self):

        localctx = DParser.TraLineRuleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_traLineRule)
        try:
            self.state = 674
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,85,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 671
                localctx.string = self.stringRule()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 672
                localctx.ref = self.referenceRule()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 673
                localctx.dlgLine = self.dlgLineRule()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DlgLineRuleContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return DParser.RULE_dlgLineRule

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class GenderedTextContext(DlgLineRuleContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a DParser.DlgLineRuleContext
            super().__init__(parser)
            self.maleLine = None # StringRuleContext
            self.maleSound = None # SoundRuleContext
            self.femaleLine = None # StringRuleContext
            self.femaleSound = None # SoundRuleContext
            self.copyFrom(ctx)

        def stringRule(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(DParser.StringRuleContext)
            else:
                return self.getTypedRuleContext(DParser.StringRuleContext,i)

        def soundRule(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(DParser.SoundRuleContext)
            else:
                return self.getTypedRuleContext(DParser.SoundRuleContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGenderedText" ):
                listener.enterGenderedText(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGenderedText" ):
                listener.exitGenderedText(self)


    class GenderNeutralTextContext(DlgLineRuleContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a DParser.DlgLineRuleContext
            super().__init__(parser)
            self.line = None # StringRuleContext
            self.sound = None # SoundRuleContext
            self.copyFrom(ctx)

        def stringRule(self):
            return self.getTypedRuleContext(DParser.StringRuleContext,0)

        def soundRule(self):
            return self.getTypedRuleContext(DParser.SoundRuleContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGenderNeutralText" ):
                listener.enterGenderNeutralText(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGenderNeutralText" ):
                listener.exitGenderNeutralText(self)


    class ReferencedTextContext(DlgLineRuleContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a DParser.DlgLineRuleContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def referenceRule(self):
            return self.getTypedRuleContext(DParser.ReferenceRuleContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterReferencedText" ):
                listener.enterReferencedText(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitReferencedText" ):
                listener.exitReferencedText(self)



    def dlgLineRule(self):

        localctx = DParser.DlgLineRuleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_dlgLineRule)
        self._la = 0 # Token type
        try:
            self.state = 689
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,89,self._ctx)
            if la_ == 1:
                localctx = DParser.GenderedTextContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 676
                localctx.maleLine = self.stringRule()
                self.state = 678
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==DParser.SOUND_STRING:
                    self.state = 677
                    localctx.maleSound = self.soundRule()


                self.state = 680
                localctx.femaleLine = self.stringRule()
                self.state = 682
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==DParser.SOUND_STRING:
                    self.state = 681
                    localctx.femaleSound = self.soundRule()


                pass

            elif la_ == 2:
                localctx = DParser.GenderNeutralTextContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 684
                localctx.line = self.stringRule()
                self.state = 686
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==DParser.SOUND_STRING:
                    self.state = 685
                    localctx.sound = self.soundRule()


                pass

            elif la_ == 3:
                localctx = DParser.ReferencedTextContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 688
                self.referenceRule()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StringRuleContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self._stringLiteralRule = None # StringLiteralRuleContext
            self.parts = list() # of StringLiteralRuleContexts

        def stringLiteralRule(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(DParser.StringLiteralRuleContext)
            else:
                return self.getTypedRuleContext(DParser.StringLiteralRuleContext,i)


        def CONCAT(self, i:int=None):
            if i is None:
                return self.getTokens(DParser.CONCAT)
            else:
                return self.getToken(DParser.CONCAT, i)

        def getRuleIndex(self):
            return DParser.RULE_stringRule

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStringRule" ):
                listener.enterStringRule(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStringRule" ):
                listener.exitStringRule(self)




    def stringRule(self):

        localctx = DParser.StringRuleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_stringRule)
        self._la = 0 # Token type
        try:
            self.state = 699
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,91,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 691
                self.stringLiteralRule()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 692
                localctx._stringLiteralRule = self.stringLiteralRule()
                localctx.parts.append(localctx._stringLiteralRule)
                self.state = 695 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 693
                    self.match(DParser.CONCAT)
                    self.state = 694
                    localctx._stringLiteralRule = self.stringLiteralRule()
                    localctx.parts.append(localctx._stringLiteralRule)
                    self.state = 697 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==DParser.CONCAT):
                        break

                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StringLiteralRuleContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifierRule(self):
            return self.getTypedRuleContext(DParser.IdentifierRuleContext,0)


        def PERCENT_STRING(self):
            return self.getToken(DParser.PERCENT_STRING, 0)

        def TILDE_STRING(self):
            return self.getToken(DParser.TILDE_STRING, 0)

        def LONG_TILDE_STRING(self):
            return self.getToken(DParser.LONG_TILDE_STRING, 0)

        def QUOTE_STRING(self):
            return self.getToken(DParser.QUOTE_STRING, 0)

        def getRuleIndex(self):
            return DParser.RULE_stringLiteralRule

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStringLiteralRule" ):
                listener.enterStringLiteralRule(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStringLiteralRule" ):
                listener.exitStringLiteralRule(self)




    def stringLiteralRule(self):

        localctx = DParser.StringLiteralRuleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_stringLiteralRule)
        try:
            self.state = 706
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [DParser.IDENTIFIER]:
                self.enterOuterAlt(localctx, 1)
                self.state = 701
                self.identifierRule()
                pass
            elif token in [DParser.PERCENT_STRING]:
                self.enterOuterAlt(localctx, 2)
                self.state = 702
                self.match(DParser.PERCENT_STRING)
                pass
            elif token in [DParser.TILDE_STRING]:
                self.enterOuterAlt(localctx, 3)
                self.state = 703
                self.match(DParser.TILDE_STRING)
                pass
            elif token in [DParser.LONG_TILDE_STRING]:
                self.enterOuterAlt(localctx, 4)
                self.state = 704
                self.match(DParser.LONG_TILDE_STRING)
                pass
            elif token in [DParser.QUOTE_STRING]:
                self.enterOuterAlt(localctx, 5)
                self.state = 705
                self.match(DParser.QUOTE_STRING)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IdentifierRuleContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(DParser.IDENTIFIER, 0)

        def getRuleIndex(self):
            return DParser.RULE_identifierRule

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIdentifierRule" ):
                listener.enterIdentifierRule(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIdentifierRule" ):
                listener.exitIdentifierRule(self)




    def identifierRule(self):

        localctx = DParser.IdentifierRuleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_identifierRule)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 708
            self.match(DParser.IDENTIFIER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ReferenceRuleContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SHARP_NUMBER(self):
            return self.getToken(DParser.SHARP_NUMBER, 0)

        def FORCED_STRING_REFERENCE(self):
            return self.getToken(DParser.FORCED_STRING_REFERENCE, 0)

        def TRANSLATION_REFERENCE(self):
            return self.getToken(DParser.TRANSLATION_REFERENCE, 0)

        def PAREN_OPEN(self):
            return self.getToken(DParser.PAREN_OPEN, 0)

        def AT(self):
            return self.getToken(DParser.AT, 0)

        def stringRule(self):
            return self.getTypedRuleContext(DParser.StringRuleContext,0)


        def PAREN_CLOSE(self):
            return self.getToken(DParser.PAREN_CLOSE, 0)

        def getRuleIndex(self):
            return DParser.RULE_referenceRule

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterReferenceRule" ):
                listener.enterReferenceRule(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitReferenceRule" ):
                listener.exitReferenceRule(self)




    def referenceRule(self):

        localctx = DParser.ReferenceRuleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 42, self.RULE_referenceRule)
        try:
            self.state = 718
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [DParser.SHARP_NUMBER]:
                self.enterOuterAlt(localctx, 1)
                self.state = 710
                self.match(DParser.SHARP_NUMBER)
                pass
            elif token in [DParser.FORCED_STRING_REFERENCE]:
                self.enterOuterAlt(localctx, 2)
                self.state = 711
                self.match(DParser.FORCED_STRING_REFERENCE)
                pass
            elif token in [DParser.TRANSLATION_REFERENCE]:
                self.enterOuterAlt(localctx, 3)
                self.state = 712
                self.match(DParser.TRANSLATION_REFERENCE)
                pass
            elif token in [DParser.PAREN_OPEN]:
                self.enterOuterAlt(localctx, 4)
                self.state = 713
                self.match(DParser.PAREN_OPEN)
                self.state = 714
                self.match(DParser.AT)
                self.state = 715
                self.stringRule()
                self.state = 716
                self.match(DParser.PAREN_CLOSE)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SharpNumberRuleContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SHARP_NUMBER(self):
            return self.getToken(DParser.SHARP_NUMBER, 0)

        def getRuleIndex(self):
            return DParser.RULE_sharpNumberRule

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSharpNumberRule" ):
                listener.enterSharpNumberRule(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSharpNumberRule" ):
                listener.exitSharpNumberRule(self)




    def sharpNumberRule(self):

        localctx = DParser.SharpNumberRuleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 44, self.RULE_sharpNumberRule)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 720
            self.match(DParser.SHARP_NUMBER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SoundRuleContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SOUND_STRING(self):
            return self.getToken(DParser.SOUND_STRING, 0)

        def getRuleIndex(self):
            return DParser.RULE_soundRule

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSoundRule" ):
                listener.enterSoundRule(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSoundRule" ):
                listener.exitSoundRule(self)




    def soundRule(self):

        localctx = DParser.SoundRuleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 46, self.RULE_soundRule)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 722
            self.match(DParser.SOUND_STRING)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx





